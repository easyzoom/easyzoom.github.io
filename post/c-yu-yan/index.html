<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="温故而知新">
<meta name="theme-color" content="#000">
<title>C语言 | EASYZOOM</title>
<link rel="shortcut icon" href="/favicon.ico?v=1668433942332">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="C语言" />
  <meta name="keywords" content="C/C++" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>EASYZOOM</span>
            </a>  
          
        </div>
        
          <p class="subtitle">精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-globe"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags" target="_self">
                  <i class="fa fa-globe"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友链
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">我是谁</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">31</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">5</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  



  <div style="width: 100%; position: relative;">
    <canvas id="canvasDiyBlock" style="width:100%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
    <script src="/media/js/magic/clock.js"></script>
  </div>

</div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://easyzoom.github.io/post/c-yu-yan/"> C语言 </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2022-04-10 23:46:18">2022-04-10</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">标签:</span>
       
      <a href="https://easyzoom.github.io/tag/H9HUbZnxv/">
        <span>C/C++</span>
      </a>
       
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >20<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >5244<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
      
    <span
      id="/post/c-yu-yan/"
      data-flag-title="C语言"
      class="meta-item pc-show leancloud_visitors"
    >
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span
        ><span class="language" data-lan="view">浏览量:</span>:<span
          class="leancloud-visitors-count"
        ></span
      ></span>
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <p><strong>1) C 和 C++ 区别</strong><br>
（1）C语言特点：<br>
a.作为一种面向过程的结构化语言，易于调试和维护；<br>
b.表现能力和处理能力极强，可以直接访问内存的物理地址；<br>
c.C语言实现了对硬件的编程操作，也适合于应用软件的开发；<br>
d.C语言还具有效率高，可移植性强等特点。<br>
（2）C++语言特点：<br>
a在C语言的基础上进行扩充和完善，使C++兼容了C语言的面向过程特点，又成为了一种面向对象的程序设计语言；<br>
b.可以使用抽象数据类型进行基于对象的编程；<br>
c.可以使用多继承、多态进行面向对象的编程；<br>
d.可以担负起以模版为特征的泛型化编程。<br>
C++与C语言的本质差别：在于C++是面向对象的，而C语言是面向过程的。或者说C++是在C语言的基础上增加了面向对象程序设计的新内容，是对C语言的一次更重要的改革，使得C++成为软件开发的重要工具。</p>
<p><strong>2.const有什么用途</strong><br>
主要有三点：<br>
1：定义只读变量，即常量<br>
2：修饰函数的参数和函数的返回值<br>
3：修饰函数的定义体，这里的函数为类的成员函数，被const修饰的成员函数代表不修改成员变量的值</p>
<p><strong>3. 指针和引用的区别</strong><br>
1：引用是变量的一个别名，内部实现是只读指针<br>
2：引用只能在初始化时被赋值，其他时候值不能被改变，指针的值可以在任何时候被改变<br>
3：引用不能为NULL，指针可以为NULL<br>
4：引用变量内存单元保存的是被引用变量的地址<br>
5：“sizeof 引用&quot; = 指向变量的大小 ， &quot;sizeof 指针&quot;= 指针本身的大小<br>
6：引用可以取地址操作，返回的是被引用变量本身所在的内存单元地址<br>
7：引用使用在源代码级相当于普通的变量一样使用，做函数参数时，内部传递的实际是变量地址</p>
<p><strong>4. C++中有了malloc / free , 为什么还需要 new / delete</strong><br>
1,malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。<br>
2,对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。<br>
对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。<br>
由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。<br>
3,因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。</p>
<p><strong>5. 编写类String 的构造函数，析构函数，拷贝构造函数和赋值函数</strong></p>
<p><strong>6. 多态的实现</strong></p>
<p><strong>7. 单链表的逆置</strong></p>
<p><strong>8. 堆和栈的区别</strong><br>
栈区stack:由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间<br>
堆区heap:需要程序员自己申请，并指明大小，在c中malloc函数<br>
如p1 = (char *)malloc(10);<br>
动态数据区一般就是“堆栈”。“栈(stack)”和“堆(heap)”是两种不同的动态数据区，栈是一种线性结构，堆是一种链式结构。进程的每个线程都有私有的“栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。一个堆栈可以通过“基地址”和“栈顶”地址来描述。全局变量和静态变量分配在静态数据区，本地变量分配在动态数据区，即堆栈中。程序通过堆栈的基地址和偏移量来访问本地变量。<br>
队列是先进先出，有出口和入口，先进去可以先出来。<br>
栈就像一个箱子，后放上去的，可以先出来<br>
堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。{堆是指程序运行是申请的动态内存，而栈只是指一种使用堆的方法(即先进后出)。<br>
栈是先进后出的，但是于堆而言却没有这个特性，两者都是存放临时数据的地方。对于堆，我们可以随心所欲的进行增加变量和删除变量，不要遵循什么次序，只要你喜欢。</p>
<p><strong>10. 不调用C/C++ 的字符串库函数，编写strcpy</strong></p>
<pre><code>char * strcpy(char * strDest,const char * strSrc)
 {
     if ((strDest==NULL)||strSrc==NULL))
            return NULL;    
      char * strDestCopy=strDest; 
      while ((*strDest++=*strSrc++)!='\0'); 
       *strDest = '\0';
        return strDestCopy;
 }
</code></pre>
<p><strong>11. 关键字static的作用</strong><br>
1.函数体内 static 变量的作用范围为该函数体，不同于 auto 变量， 该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值<br>
2.在模块内的 static 全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问<br>
3.在模块内的static 函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内<br>
4.在类的static 成员变量属于整个类所拥有，对类的所以对象只有一份拷贝<br>
5.在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的 static 成员变量<br>
介绍它最重要的一条：隐藏。（static函数，static变量均可） --&gt; 对应上面的2、3项<br>
当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。<br>
举例来说明。同时编译两个源文件，一个是a.c，另一个是main.c。<br>
1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。<br>
2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。<br>
3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。</p>
<p><strong>12.sizeof和strlen区别？</strong><br>
sizeof是运算符，在头文件中typedef为unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。<br>
它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。具体而言，当参数分别如下时，sizeof返回的值表示的含义如下：数组——编译时分配的数组空间大小；指针——存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为4）。<br>
strlen是函数，要在运行时才能计算。参数必须是字符型指针。当数组名作为参数传入时，实际上数组就退化成指针了。<br>
它的功能是：返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。返回的长度大小不包括NULL。</p>
<p><strong>13.C语言的四种拷贝函数</strong><br>
strcpy()函数用来复制字符串，其原型为：char*strcpy(char *dest,const char *src);<br>
【参数】dest 为目标字符串指针，src为源字符串指针。<br>
注意：src 和 dest 所指的内存区域不能重叠，且 dest必须有足够的空间放置 src 所包含的字符串（包含结束符NULL）。<br>
【返回值】成功执行后返回目标数组指针dest。<br>
注意：如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(bufferOverflow)的错误情况，在编写程序时需要特别留意，或者用strncpy()来取代。</p>
<p>memcpy()用来复制内存，其原型为：void *memcpy ( void * dest, const void * src, size_t num );<br>
memcpy()会复制src所指的内存内容的前num个字节到dest所指的内存地址上。<br>
memcpy()并不关心被复制的数据类型，只是逐字节地进行复制，这给函数的使用带来了很大的灵活性，可以面向任何数据类型进行复制。<br>
注意：dest 指针要分配足够的空间，也即大于等于 num字节的空间。如果没有分配空间，会出现断错误。<br>
dest和src所指的内存空间不能重叠（如果发生了重叠，使用 memmove() 会更加安全）。与 strcpy() 不同的是，memcpy() 会完整的复制 num个字节，不会因为遇到“\0”而结束。<br>
【返回值】返回指向 dest 的指针。注意返回的指针类型是void，使用时一般要进行强制类型转换。<br>
处理内存重叠时的情况：先将内容复制到类似缓冲区的地方，再用缓冲区中的内容覆盖 dest指向的内存</p>
<p>memmove()用来复制内存内容，其原型为：void *memmove(void *dest, const void *src, size_t num);<br>
说明：memmove()与memcpy()类似都是用来复制src所指的内存内容前num个字节到dest所指的地址上。不同的是，memmove()更为灵活，当src和dest所指的内存区域重叠时，memmove()仍然可以正确的处理，不过执行效率上会比使用memcpy()略慢些。</p>
<p>strncpy()用来复制字符串的前n个字符，其原型为：char *strncpy(char *dest, const char *src, size_t n);<br>
【参数说明】dest 为目标字符串指针，src 为源字符串指针。<br>
【返回值】返回字符串dest。<br>
strncpy()会将字符串src前n个字符拷贝到字符串dest。<br>
不像strcpy()，strncpy()不会向dest追加结束标记'\0'，这就引发了很多不合常理的问题，将在下面的示例中说明。<br>
注意：src和dest所指的内存区域不能重叠，且dest必须有足够的空间放置n个字符。使用strncpy()最安全方式是使n等于strlen(src)+1，即拷贝整个字符串，同时将'\0'追加到dest。</p>
<p><strong>14.用变量a给出下面的定义</strong><br>
a) 一个整型数（An integer）<br>
b) 一个指向整型数的指针（A pointer to an integer）<br>
c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）<br>
d) 一个有10个整型数的数组（An array of 10 integers）<br>
e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）<br>
f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）<br>
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）<br>
h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integerargument and return an integer ）<br>
答案是：<br>
a) int a; // An integer<br>
b) int *a; // A pointer to an integer<br>
c) int **a; // A pointer to a pointer to an integer<br>
d) int a[10]; // An array of 10 integers<br>
e) int *a[10]; // An array of 10 pointers to integers<br>
f) int (*a)[10]; // A pointer to an array of 10 integers<br>
g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer<br>
h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer</p>
<p><strong>15.结构与联合有和区别？</strong><br>
答：(1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。<br>
(2). 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的</p>
<p><strong>16.进程与线程的区别</strong><br>
进程是拥有资源的基本单位，线程是调度和分配的基本单位<br>
线程和进程都可以并发执行<br>
中断与异常的区别<br>
中断是外部硬件产生的电信号通过处理器的中断端口打断处理器的处理过程<br>
异常是处理器内部执行到错误指令、或者在执行期间出现错误，必须靠内核处理的时候就会产生一个异常</p>
<p><strong>17.三种内存分配</strong><br>
1、从静态数据区分配：在程序编译的时候就已经分配好了，程序运行区间都存在<br>
2、从栈上分配：在执行函数的时候，函数内部的局部变量可以在栈上申请空间，并随函数的结束而释放<br>
3、从堆上分配：手动分配空间使用new和malloc，释放时使用deleted和free</p>
<p><strong>18.为什么不能在中断中使用printf</strong><br>
printf不能在中断中被调用的原因是它是一个不可重入函数</p>
<p>printf不能在中断中被调用的原因是它是一个不可重入函数，而在中断中要避免调用不可重入函数，首先我们先说说什么是可重入函数，什么是不可重入函数<br>
简单说来，区分一个函数是否可重入就是看这个函数能否在未返回的时候再次被调用。而造成一个函数不可重入的原因往往是使用了全局变量，如果一个函数未返回再执行一次会导致对全局变量的操作是不安全的。就例如我们常用的printf、malloc、free都是不可重入的函数，printf会引用全局变量stdout，malloc，free会引用全局的内存分配表，在多线程的环境下，如果没有很好的处理数据保护和互斥访问，就会发生错误<br>
在unix里面通常都有加上_r后缀的同名可重入函数版本<br>
如果实在没有，不妨在可预见的发生错误的地方尝试加上保护锁同步机制等等<br>
printf，malloc，free等都是不可重入函数<br>
在多线程的环境下，如果没有很好的处理数据保护和互斥访问，就会发生错误<br>
在unix里面通常都有加上_r后缀的同名可重入函数版本<br>
如果实在没有，不妨在可预见的发生错误的地方尝试加上保护锁同步机制等等</p>
<p><strong>19.什么是不可重入函数？</strong><br>
可重入函数主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入 OS 调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。</p>
<p>满足下列条件的函数多数是不可重入的：<br>
函数体内使用了静态（static）的数据结构；<br>
函数体内调用了 malloc() 或者 free() 函数；<br>
函数体内调用了标准 I/O 函数;</p>
<p><strong>20.如何写可重入的函数</strong><br>
我们只要遵循几条规则，写出来的函数就是可重入的：</p>
<p>不要使用全局变量。因为别的代码很可能覆盖这些变量值<br>
在和硬件发生交互的时候，切记执行类似disinterrupt()之类的操作，就是关闭硬件中断。完成交互记得打开中断，在有些系列上，这叫做“进入/退出核心”或者用OS_ENTER_KERNAL/OS_EXIT_KERNAL来描述<br>
不能调用任何不可重入的函数<br>
谨慎使用堆栈。最好先在使用前先OS_ENTER_KERNAL<br>
总而言之我们就是要保证中断是安全的！</p>
<p>1.在函数体内不访问那些全局变量；<br>
2.如果必须访问全局变量，记住利用互斥信号量来保护全局变量。或者调用该函数前关中断，调用后再开中断；<br>
3.不使用静态局部变量；<br>
4.坚持只使用缺省态（auto）局部变量；<br>
5.在和硬件发生交互的时候，切记关闭硬件中断。完成交互记得打开中断，在有些系列上，这叫做“进入/退出核心”或者用 OS_ENTER_KERNAL/OS_EXIT_KERNAL 来描述；<br>
6.不能调用任何不可重入的函数；<br>
7.谨慎使用堆栈。最好先在使用前先 OS_ENTER_KERNAL；这是临界区保护</p>
<p><strong>21. <strong>attribute</strong>((packed))详解</strong><br>
<strong>attribute</strong> ((packed)) 的作用就是告诉编译器取消结构在编译过程中的优化对齐,按照实际占用字节数进行对齐，是GCC特有的语法。这个功能是跟操作系统没关系，跟编译器有关，gcc编译器不是紧凑模式的，我在windows下，用vc的编译器也不是紧凑的，用tc的编译器就是紧凑的。例如：<br>
在TC下：struct my{ char ch; int a;} sizeof(int)=2;sizeof(my)=3;（紧凑模式）<br>
在GCC下：struct my{ char ch; int a;} sizeof(int)=4;sizeof(my)=8;（非紧凑模式）<br>
在GCC下：struct my{ char ch; int a;}<strong>attrubte</strong> ((packed)) sizeof(int)=4;sizeof(my)=5</p>
<p><strong>22.static __INLINE 内联函数</strong><br>
_inline函数也称为内联函数或内嵌函数，_inline定义的类的内联函数，函数代码被放入符号调用表，使用时直接展开，不需要调用，即在编译期间将所调用的函数的代码直接嵌入到主调函数中，是一种以空间换时间的函数。<br>
根据上面的定义可以知道，如果static inline关键字生效（因为只有编译器有最终决定权，我们只有建议权，这点在后面会细讲），static inline会以一种类似于宏定义的方式，将调用被static inline修饰的函数的语句替换为那个函数体对应的指令，但实际上只是inline的作用，static作用其实是维护代码的健壮性，实验中会加以证明。 所以：</p>
<p>好处：<br>
减少调用函数时的开销，如：<br>
减少传参时可能引起的压栈出栈的开销。<br>
减少PC跳转时对流水线的破坏。<br>
坏处： * 代码所占体积会更大。</p>
<p><strong>23.#if defined和#if !defined(c语言的宏定义)</strong><br>
因为对于一个大程序而言,我们可能要定义很多常量( 不管是放在源文件还是头文件 ),那么我们有时考虑定义某个常量时,我们就必须返回检查原来此常量是否定义,但这样做很麻烦.if defined宏正是为这种情况提供了解决方案.举个例子,如下:<br>
#define ....<br>
#define ....<br>
....<br>
....<br>
#define a 100<br>
....<br>
此时，我们要检查a是否定义（假设我们已经记不着这点了）,或者我们要给a一个不同的值，就加入如下句子<br>
#if defined a<br>
#undef a<br>
#define a 200<br>
#endif<br>
上述语句检验a是否被定义，如果被定义，则用#undef语句解除定义，并重新定义a为200<br>
同样，检验a是否定义：<br>
#ifndef a    //如果a没有被定义<br>
#define a 100<br>
#endif</p>
<p>以上所用的宏中：#undef为解除定义，#ifndef是if not defined的缩写，即如果没有定义。<br>
这就是#if defined 的唯一作用！<br>
#define a 100<br>
#endif<br>
以上所用的宏中：#undef为解除定义，#ifndef是if not defined的缩写，即如果没有定义。<br>
这就是#if defined 的唯一作用！<br>
1）<br>
#if defined XXX_XXX<br>
#endif<br>
是条件编译，是根据你是否定义了XXX_XXX这个宏，而使用不同的代码。<br>
一般.h文件里最外层的<br>
#if !defined XXX_XXX<br>
#define XXX_XXX<br>
#endif<br>
是为了防止这个.h头文件被重复include。<br>
2）<br>
#error XXXX<br>
是用来产生编译时错误信息XXXX的，一般用在预处理过程中；<br>
例子：<br>
#if !defined(__cplusplus)<br>
#error C++ compiler required.<br>
#endif</p>

            </div>
            
              <div class="reward-btn">
                <div class="reward-btn-text">赞赏</div>
              </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      我是谁
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://easyzoom.github.io/post/c-yu-yan/" title="C语言">https://easyzoom.github.io/post/c-yu-yan/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://easyzoom.github.io/tag/H9HUbZnxv/"># C/C++</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="排序算法" href="https://easyzoom.github.io/post/pai-xu-suan-fa/">排序算法</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="排序算法" href="https://easyzoom.github.io/post/pai-xu-suan-fa/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="51单片机" href="https://easyzoom.github.io/post/51-dan-pian-ji/">51单片机</a>
        <a class="nav-mobile-next" title="51单片机" href="https://easyzoom.github.io/post/51-dan-pian-ji/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  <script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<div id="vcomments" style="padding: 10px 0px 0px 0px"></div>

<style>
  .v .veditor {
    min-height: 10rem;
    background-image: url('');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: right;
    background-color: rgba(255, 255, 255, 0);
    resize: none;
  }

  .v .vwrap {
    border: 1px solid #000 !important;
  }

  .v .vbtn {
    padding: .4rem 1.2rem !important;
    border-color: #fff !important;
    background-color: #49b1f5 !important;
    color: #fff !important;
    font-size: .7rem !important;
  }

  .v .vcards .vcard .vh .vmeta .vat {
    padding: 0 .8rem !important;
    border: 1px solid #00c4b6 !important;
    border-radius: 5px !important;
    color: #00c4b6 !important;
  }
</style>
<script>
  new Valine({
    el: '#vcomments',
    appId: '',
    appKey: '',
    avatar: '',
    placeholder: '',
    pageSize: '',
    lang: 'zh-cn',
    enableQQ: 'true' === 'true',
    visitor: 'true' === 'true',
    highlight: 'true' === 'true',
    avatarForce: 'true' === 'true',
    serverURLs: '',
		recordIP: 'true' === 'true',
  });
</script>

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
    
        <div class="gemini back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
          
            
              <div class="bg-img">
                <img src="\media\images\custom-bgImg.jpg" />
              </div>
              
                
                  
                    
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 5px;bottom: px;"
    data-key="">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    

      <div class="message" style="opacity:0"></div>
      <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
          <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off"
            placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
          <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off"
            placeholder="要和我聊什么呀？" />
          <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
      </div>
      <input name="live_talk" id="live_talk" value="1" type="hidden" />
      <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input id="duType" value="douqilai" type="hidden">
        
      </div>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'tororo'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'aoba') {
				AIimgSrc.push(message_Path + "model/aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'aoba') {
							model = message_Path + "model/aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
                      
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "true";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip"> </p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/linux-za-ji/"" data-c="
          &lt;h1 id=&#34;终端工具terminator&#34;&gt;终端工具terminator&lt;/h1&gt;
&lt;p&gt;垂直分屏：ctrl+shift+e&lt;/p&gt;
&lt;p&gt;水平分屏：ctrl+shift+o&lt;/p&gt;
">linux-杂记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/qemuvscodekernel/"" data-c="
          &lt;p&gt;123&lt;/p&gt;
">qemu+vscode+kernel</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/docker/"" data-c="
          &lt;p&gt;123&lt;/p&gt;
">Docker</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/iperf/"" data-c="
          &lt;pre&gt;&lt;code&gt;设置udp缓存大小
    sysctl -w net.ipv4.udp_rmem_min=4194304
    sysctl -w net.ipv4.udp_wmem_min=4194304
    sysctl -w net.core.rmem_max=8388608
    sysctl -w net.core.wmem_max=8388608

    echo 2129920 &amp;gt; /proc/sys/net/core/rmem_max    
    echo 2129920 &amp;gt; /proc/sys/net/core/rmem_default

server:  iperf3.exe -s  -i 1
client:  iperf3 -c 192.168.0.126 -u -i 1 -w 4M -l 10K -b 1000M -t 15

    -c &amp;lt;host&amp;gt; client端，&amp;lt;host&amp;gt; host地址；
    -u udp模式；
    -i &amp;lt;n&amp;gt; 打印间隔；
    -w tcp窗口大小/udp socket buffer 大小；
    -l 读写buffer大小；
    -b 带宽；
    -t 时长
&lt;/code&gt;&lt;/pre&gt;
">iperf工具</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/hello/"" data-c="
          &lt;p&gt;👏  欢迎来到 &lt;strong&gt;EASYZOOMの空间&lt;/strong&gt; ！&lt;br&gt;
✍️ 我将用它来记录我的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;!-- 
[Github](https://github.com/getgridea/gridea)  
[Gridea 主页](https://gridea.dev/)  
[示例网站](http://fehey.com/)

## 特性👇
📝  你可以使用最酷的 **Markdown** 语法，进行快速创作  

🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片  

🏷️  你可以对文章进行标签分组  

📋  你可以自定义菜单，甚至可以创建外部链接菜单  

💻  你可以在 **Windows**，**MacOS** 或 **Linux** 设备上使用此客户端  

🌎  你可以使用 **𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌** 或 **Coding Pages** 向世界展示，未来将支持更多平台  

💬  你可以进行简单的配置，接入 [Gitalk](https://github.com/gitalk/gitalk) 或 [DisqusJS](https://github.com/SukkaW/DisqusJS) 评论系统  

🇬🇧  你可以使用**中文简体**或**英语**  

🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力  

🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步  

🌱 当然 **Gridea** 还很年轻，有很多不足，但请相信，它会不停向前 🏃

未来，它一定会成为你离不开的伙伴

尽情发挥你的才华吧！

😘 Enjoy~ --&gt;
">Hello Guys</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/jian-dan-suan-fa/"" data-c="
          &lt;p&gt;在单片机进行数据采集时，会遇到数据的随机误差，随机误差是由随机干扰引起的，其特点是在相同条件下测量同一量时，其大小和符号会现无规则的变化而无法预测，但多次测量的结果符合统计规律。&lt;/p&gt;
&lt;p&gt;为克服随机干扰引起的误差，硬件上可采用滤波技术，软件上可采用软件算法实现数字滤波。&lt;/p&gt;
&lt;p&gt;数字滤波算法克服随机干扰的误差具有以下优点：&lt;/p&gt;
&lt;p&gt;1、数字滤波无需其他的硬件成本，只有一个计算过程，可靠性高，不存在阻抗匹配问题。尤其是数字滤波可以对频率很低的信号进行滤波，这是模拟滤波器做不到的。&lt;br&gt;
2、数字滤波使用软件算法实现，多输入通道可共用一个滤波程序，降低系统开支。&lt;br&gt;
3、只要适当改变滤波器的滤波程序或运算，就能方便地改变其滤波特性，这对于滤除低频干扰和随机信号会有较大的效果。&lt;br&gt;
4、在单片机系统中常用的滤波算法有限幅滤波法、中值滤波法、算术平均滤波法、加权平均滤波法、滑动平均滤波等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.限幅滤波算法&lt;/strong&gt;&lt;br&gt;
该运算的过程中将两次相邻的采样相减，求出其增量，然后将增量的绝对值，与两次采样允许的最大差值A进行比较。&lt;br&gt;
A的大小由被测对象的具体情况而定，如果小于或等于允许的最大差值，则本次采样有效；否则取上次采样值作为本次数据的样本。&lt;br&gt;
算法的程序代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define A //允许的最大差值
char data; //上一次的数据
char filter()
{
    char datanew; //新数据变量
    datanew=get_data(); //获得新数据变量
    if((datanew-data)&amp;gt;A||(data-datanew&amp;gt;A))
        return data;
    else
        return datanew;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：限幅滤波法主要用于处理变化较为缓慢的数据，如温度、物体的位置等。使用时，关键要选取合适的门限制A。通常这可由经验数据获得，必要时可通过实验得到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.中值滤波算法&lt;/strong&gt;&lt;br&gt;
该运算的过程是对某一参数连续采样N次(N一般为奇数)，然后把N次采样的值按从小到大排列，再取中间值作为本次采样值，整个过程实际上是一个序列排序的过程。&lt;br&gt;
算法的程序代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define N 11 //定义获得的数据个数
char filter()
{
    char value_buff[N]; //定义存储数据的数组 
    char count,i,j,temp;
    for(count=0;count&amp;lt;N;count++)
    {
        value_buf[count]=get_data();
        delay(); //如果采集数据比较慢，那么就需要延时或中断
    }
    for(j=0;j&amp;lt;N;j++)//冒泡排序
    {
        bool flag = flase;
        for(i=0;i&amp;lt;N-j;i++)
        {
            if(value_buff[i]&amp;gt;value_buff[i+1])
            {
                temp=value_buff[i];
                value_buff[i]=value_buff[i+1];
                value_buff[i+1]=temp;
                flag=true;
            }
        }
        if(flag==flase)
        {
            return;
        }
    }
  return value_buff[(N-1)/2];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：中值滤波比较适用于去掉由偶然因素引起的波动和采样器不稳定而引起的脉动干扰。若被测量值变化比较慢，采用中值滤波法效果会比较好，但如果数据变化比较快，则不宜采用此方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.算术平均滤波算法&lt;/strong&gt;&lt;br&gt;
该算法的基本原理很简单，就是连续取N次采样值后进行算术平均。&lt;br&gt;
算法的程序代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char filter()
{
    int sum=0;
    for(count=0;count&amp;lt;N;count++)
    {
        sum+=get_data();
        delay():
    }
    return (char)(sum/N);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：算术平均滤波算法适用于对具有随机干扰的信号进行滤波。这种信号的特点是有一个平均值，信号在某一数值附近上下波动。&lt;br&gt;
信号的平均平滑程度完全到决于N值。当N较大时，平滑度高，灵敏度低;当N较小时，平滑度低，但灵敏度高。为了方便求平均值，N一般取4、8、16、32之类的2的整数幂，以便在程序中用移位操作来代替除法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.加权平均滤波算法&lt;/strong&gt;&lt;br&gt;
由于前面所说的“算术平均滤波算法”存在平滑度和灵敏度之间的矛盾。为了协调平滑度和灵敏度之间的关系，可采用加权平均滤波。&lt;br&gt;
它的原理是对连续N次采样值分别乘上不同的加权系数之后再求累加，加权系数一般先小后大，以突出后面若干采样的效果，加强系统对参数变化趋势的认识。&lt;br&gt;
各个加权系数均小于1的小数，且满足总和等于1的结束条件。这样加权运算之后的累加和即为有效采样值。其中加权平均数字滤波的数学模型是：&lt;br&gt;
式中：D为N个采样值的加权平均值：XN-i为第N-i次采样值;N为采样次数;Ci为加权系数。加权系数Ci体现了各种采样值在平均值中所占的比例。&lt;br&gt;
一般来说采样次数越靠后，取的比例越大，这样可增加新采样在平均值中所占的比重。&lt;br&gt;
加权平均值滤波法可突出一部分信号抵制另一部分信号，以提高采样值变化的灵敏度。&lt;br&gt;
样例程序代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char jq[N]={1,2,3,4,5,6,7,8,9,10,11,12}; //code数组为加权系数表，存在程序存储区
char sum_jq=1+2+3+4+5+6+7+8+9+10+11+12;

char filter()
{
    char count;
    char value_buff[N];
    int sum=0;
    for(count=0;count&amp;lt;N;count++)
    {
        value_buff[count]=get_data();
        delay();
    }
    for(count=0;count&amp;lt;N;count++)
        sum+=value_buff[count]*jq[count];
    return (char)(sum/sum_jq);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5.滑动平均滤波算法&lt;/strong&gt;&lt;br&gt;
以上介绍和各种平均滤波算法有一个共同点，即每获取一个有效采样值必须连续进行若干次采样，当采速度慢时，系统的实时得不到保证。&lt;br&gt;
这里介绍的滑动平均滤波算法只采样一次，将一次采样值和过去的若干次采样值一起求平均，得到的有效采样值即可投入使用。&lt;br&gt;
如果取N个采样值求平均，存储区中必须开辟N个数据的暂存区。&lt;br&gt;
每新采集一个数据便存入暂存区中，同时去掉一个最老数据，保存这N个数据始终是最新更新的数据。采用环型队列结构可以方便地实现这种数据存放方式。&lt;br&gt;
程序代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char value_buff[N];
char i=0;

char filter()
{
    char count;
    int sum=0;
    value_buff[i++]=get_data();
    if(i==N)
        i=0;
    for(count=0;count&amp;lt;N;count++)
        sum=value_buff[count];
    return (char)(sum/N);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;6.低通滤波&lt;/strong&gt;&lt;br&gt;
将普通硬件RC低通滤波器的微分方程用差分方程来表求，变可以采用软件算法来模拟硬件滤波的功能，经推导，低通滤波算法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Yn=a* Xn+(1-a) *(Yn-1)
式中 Xn——本次采样值
Yn-1——上次的滤波输出值;
a——滤波系数，其值通常远小于1;
Yn——本次滤波的输出值。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由上式可以看出，本次滤波的输出值主要取决于上次滤波的输出值(注意不是上次的采样值，这和加权平均滤波是有本质区别的)，本次采样值对滤波输出的贡献是比较小的，但多少有些修正作用，这种算法便模拟了具体有教大惯性的低通滤波器功能。滤波算法的截止频率可用以下式计算：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fL=a/2Pit pi为圆周率3.14…
式中 a——滤波系数;
t——采样间隔时间;
例如：当t=0.5s(即每秒2次)，a=1/32时;
fL=(1/32)/(2*3.14*0.5)=0.01Hz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当目标参数为变化很慢的物理量时，这是很有效的。另外一方面，它不能滤除高于1/2采样频率的干搅信号，本例中采样频率为2Hz，故对1Hz以上的干搅信号应采用其他方式滤除，&lt;br&gt;
低通滤波算法程序于加权平均滤波相似，但加权系数只有两个：a和1-a。为计算方便，a取一整数，1-a用256-a，来代替，计算结果舍去最低字节即可，因为只有两项，a和1-a，均以立即数的形式编入程序中，不另外设表格。&lt;br&gt;
虽然采样值为单元字节(8位A/D)。为保证运算精度，滤波输出值用双字节表示，其中一个字节整数，一字节小数，否则有可能因为每次舍去尾数而使输出不会变化。&lt;br&gt;
设Yn-1存放在30H(整数)和31H(小数)两单元中，Yn存放在32H(整数)和33H(小数)中。&lt;/p&gt;
">简单算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/freertos/"" data-c="
          &lt;h1 id=&#34;freertos的实用调试函数之vtasklist&#34;&gt;freertos的实用调试函数之vTaskList&lt;/h1&gt;
&lt;p&gt;第一列是任务名&lt;/p&gt;
&lt;p&gt;第二列状态X表示的是运行态，R表示就绪，B表示阻塞，S表示挂起，D表示删除&lt;/p&gt;
&lt;p&gt;第三列表示的是就是任务优先级了&lt;/p&gt;
&lt;p&gt;第四列表示剩余堆栈历史最小剩余值&lt;/p&gt;
&lt;p&gt;第五列表示任务编号&lt;/p&gt;
">freertos</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/whiptail-zhi-ling/"" data-c="
          &lt;p&gt;交互式shell脚本对话框----whiptail指令&lt;/p&gt;
&lt;p&gt;whiptail 是替代 dialog 的实现,它基于 newt 库.而 newt 则是为了简化 ncurses 开发而产生的新的 tty 下的UI库.&lt;/p&gt;
&lt;p&gt;所以说一切都是新的.&lt;/p&gt;
&lt;p&gt;whiptail是Linux不需要另行安装，默认就有的，其它的比如dialog需要另行安装，很麻烦，虽然功能比较好些。&lt;/p&gt;
&lt;p&gt;现在默认情况下主要的发行版本(fedora, ubuntu, archlinux确认)默认提供的是 whiptail 和 newt ,而 dialog 和 ncurses 需要手动安装.&lt;/p&gt;
&lt;p&gt;产生一个消息框&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1653832874372.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;语法：
whiptail --title &amp;quot;&amp;lt;message box title&amp;gt;&amp;quot; --msgbox &amp;quot;&amp;lt;text to show&amp;gt;&amp;quot; &amp;lt;height&amp;gt; &amp;lt;width&amp;gt;
实例：
whiptail --title &amp;quot;Message box title&amp;quot; --msgbox &amp;quot; Choose Ok to continue.&amp;quot; 10 60
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;yes/no对话框&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1653833090486.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;语法：
whiptail --title &amp;quot;&amp;lt;dialog box title&amp;gt;&amp;quot; --yesno &amp;quot;&amp;lt;text to show&amp;gt;&amp;quot; &amp;lt;height&amp;gt; &amp;lt;width&amp;gt;
实例：
#!/bin/bash
if (whiptail --title &amp;quot;Yes/No Box&amp;quot; --yesno &amp;quot;Choose between Yes and No.&amp;quot; 10 60) then
    echo &amp;quot;You chose Yes. Exit status was $?.&amp;quot;
else
    echo &amp;quot;You chose No. Exit status was $?.&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者也可以是自定义的选项，实例如下：&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1653833144268.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
if (whiptail --title &amp;quot;Yes/No Box&amp;quot; --yes-button &amp;quot;Man&amp;quot; --no-button &amp;quot;Woman&amp;quot;  --yesno &amp;quot;What is your gender?&amp;quot; 10 60) then
    echo &amp;quot;You chose Man Exit status was $?.&amp;quot;
else
    echo &amp;quot;You chose Woman. Exit status was $?.&amp;quot;
fi
当选择左边选项的时候输出的是0，选择右边选项的时候输出的是1。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表单输入框&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1653833261027.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;语法：
whiptail --title &amp;quot;&amp;lt;input box title&amp;gt;&amp;quot; --inputbox &amp;quot;&amp;lt;text to show&amp;gt;&amp;quot; &amp;lt;height&amp;gt; &amp;lt;width&amp;gt; &amp;lt;default-text&amp;gt;
实例：
#!/bin/bash
NAME=$(whiptail --title &amp;quot;Free-form Input Box&amp;quot; --inputbox &amp;quot;What is your pet&#39;s name?&amp;quot; 10 60 Peter 3&amp;gt;&amp;amp;1 1&amp;gt;&amp;amp;2 2&amp;gt;&amp;amp;3)
 
exitstatus=$?
if [ $exitstatus = 0 ]; then
    echo &amp;quot;Your name is:&amp;quot; $NAME
else
    echo &amp;quot;You chose Cancel.&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;密码输入框&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1653833361926.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;语法：
whiptail --title &amp;quot;&amp;lt;password box title&amp;gt;&amp;quot; --passwordbox &amp;quot;&amp;lt;text to show&amp;gt;&amp;quot; &amp;lt;height&amp;gt; &amp;lt;width&amp;gt;
实例：
#!/bin/bash
PASSWORD=$(whiptail --title &amp;quot;Password Box&amp;quot; --passwordbox &amp;quot;Enter your password and choose Ok to continue.&amp;quot; 10 60 3&amp;gt;&amp;amp;1 1&amp;gt;&amp;amp;2 2&amp;gt;&amp;amp;3)
 
exitstatus=$?
if [ $exitstatus = 0 ]; then
    echo &amp;quot;Your password is:&amp;quot; $PASSWORD
else
    echo &amp;quot;You chose Cancel.&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;菜单栏&lt;br&gt;
提供一个单项选择的菜单栏&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1653833555617.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;语法：
whiptail --title &amp;quot;&amp;lt;menu title&amp;gt;&amp;quot; --menu &amp;quot;&amp;lt;text to show&amp;gt;&amp;quot; &amp;lt;height&amp;gt; &amp;lt;width&amp;gt; &amp;lt;menu height&amp;gt; [ &amp;lt;tag&amp;gt; &amp;lt;item&amp;gt; ] . . .
实例：
#!/bin/bash
OPTION=$(whiptail --title &amp;quot;Menu Dialog&amp;quot; --menu &amp;quot;Choose your favorite programming language.&amp;quot; 15 60 4 \
&amp;quot;1&amp;quot; &amp;quot;Python&amp;quot; \
&amp;quot;2&amp;quot; &amp;quot;Java&amp;quot; \
&amp;quot;3&amp;quot; &amp;quot;C&amp;quot; \
&amp;quot;4&amp;quot; &amp;quot;PHP&amp;quot;  3&amp;gt;&amp;amp;1 1&amp;gt;&amp;amp;2 2&amp;gt;&amp;amp;3)
 
exitstatus=$?
if [ $exitstatus = 0 ]; then
    echo &amp;quot;Your favorite programming language is:&amp;quot; $OPTION
else
    echo &amp;quot;You chose Cancel.&amp;quot;
fi
此处的选择输出的内容为你选择的标签的‘tag’位置，上面实例中的‘1’、‘2’、‘3’、‘4’
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;radiolist对话框&lt;br&gt;
该对话框是单选对话框，你可以控制默认的选择位置，即使你在脚本中默认选择多个，他也只会输出一个结果&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1653833576310.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;语法：
whiptail --title &amp;quot;&amp;lt;radiolist title&amp;gt;&amp;quot; --radiolist &amp;quot;&amp;lt;text to show&amp;gt;&amp;quot; &amp;lt;height&amp;gt; &amp;lt;width&amp;gt; &amp;lt;list height&amp;gt; [ &amp;lt;tag&amp;gt; &amp;lt;item&amp;gt; &amp;lt;status&amp;gt; ] . . .
实例：
#!/bin/bash
DISTROS=$(whiptail --title &amp;quot;Test Checklist Dialog&amp;quot; --radiolist \
&amp;quot;What is the Linux distro of your choice?&amp;quot; 15 60 4 \
&amp;quot;debian&amp;quot; &amp;quot;Venerable Debian&amp;quot; ON \
&amp;quot;ubuntu&amp;quot; &amp;quot;Popular Ubuntu&amp;quot; OFF \
&amp;quot;centos&amp;quot; &amp;quot;Stable CentOS&amp;quot; OFF \
&amp;quot;mint&amp;quot; &amp;quot;Rising Star Mint&amp;quot; OFF 3&amp;gt;&amp;amp;1 1&amp;gt;&amp;amp;2 2&amp;gt;&amp;amp;3)
 
exitstatus=$?
if [ $exitstatus = 0 ]; then
    echo &amp;quot;The chosen distro is:&amp;quot; $DISTROS
else
    echo &amp;quot;You chose Cancel.&amp;quot;
fi　　
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多选对话框&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1653833590818.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;语法：
whiptail --title &amp;quot;&amp;lt;checklist title&amp;gt;&amp;quot; --checklist &amp;quot;&amp;lt;text to show&amp;gt;&amp;quot; &amp;lt;height&amp;gt; &amp;lt;width&amp;gt; &amp;lt;list height&amp;gt; [ &amp;lt;tag&amp;gt; &amp;lt;item&amp;gt; &amp;lt;status&amp;gt; ] . . .
实例：
#!/bin/bash
DISTROS=$(whiptail --title &amp;quot;Checklist Dialog&amp;quot; --checklist \
&amp;quot;Choose preferred Linux distros&amp;quot; 15 60 4 \
&amp;quot;debian&amp;quot; &amp;quot;Venerable Debian&amp;quot; ON \
&amp;quot;ubuntu&amp;quot; &amp;quot;Popular Ubuntu&amp;quot; OFF \
&amp;quot;centos&amp;quot; &amp;quot;Stable CentOS&amp;quot; ON \
&amp;quot;mint&amp;quot; &amp;quot;Rising Star Mint&amp;quot; OFF 3&amp;gt;&amp;amp;1 1&amp;gt;&amp;amp;2 2&amp;gt;&amp;amp;3)
 
exitstatus=$?
if [ $exitstatus = 0 ]; then
    echo &amp;quot;Your favorite distros are:&amp;quot; $DISTROS
else
    echo &amp;quot;You chose Cancel.&amp;quot;
fi　　
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进度条&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1653833922352.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;语法：
whiptail --gauge &amp;quot;&amp;lt;test to show&amp;gt;&amp;quot; &amp;lt;height&amp;gt; &amp;lt;width&amp;gt; &amp;lt;inital percent&amp;gt;
实例：
#!/bin/bash
{
    for ((i = 0 ; i &amp;lt;= 100 ; i+=20)); do
        sleep 1
        echo $i
    done
} | whiptail --gauge &amp;quot;Please wait while installing&amp;quot; 6 60 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;3&amp;gt;&amp;amp;1 1&amp;gt;&amp;amp;2 2&amp;gt;&amp;amp;3 含义&lt;/p&gt;
&lt;p&gt;1、Linux 的标准输入输出流只有三种，即 0-stdin 、1-stdout、2-stderr&lt;br&gt;
2、&amp;amp;标准流 是一个指向标准流的指针，如果没有 &amp;amp; ，就是创建的一个普通的文件句柄。&lt;br&gt;
3、&amp;gt;&amp;amp;标准流 指将某个文件重定向到另一个流&lt;br&gt;
4、这里的 3&amp;gt;&amp;amp;1 ,的含义是：先创建一个文件句柄 3，将其重定向到1(out),再将 1 重定向 2 ，最后再将 2 重定向到 3 。这么绕了一圈就是初学编程时交换两个变量的过程，将 error 的内容重定向到 out 了，out 重定向到 error 。&lt;br&gt;
这三个命令的作用类似这个简单的 swap 函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int swap(int a,int b){   int temp = a;//临时容器装 a，空出 a 容器   a=b;//将 b 放入 a 容器，空出 b 容器   b=temp;//再将临时容器中的内容放入 b 容器}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里为什么要交换 out 和 err 呢？&lt;/p&gt;
&lt;p&gt;可能是这个 menu 命令不关注本身的 out 信息，但是却关注其 err 信息，它的正常选项会返回给 OPTION ，然后根据命令的退出状态处理脚本的逻辑。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;显示脚本参数（$0、$?、$*、$@、$#、$$、$!）（本质上属于变量替换）

$0：就是该bash文件名,个位数的，可直接使用数字，但两位数以上，则必须使用 {} 符号来括住，如${10}.
$?：是上一指令的返回值，成功是0，不成功是1。一般来说，UNIX(linux) 系统的进程以执行系统调用exit() 来结束的。这个回传值就是status值。回传给父进程，用来检查子进程的执行状态。一般指令程序倘若执行成功，其回传值为 0；失败为 1。
$*：所有脚本参数的内容：就是调用调用本bash shell的参数。 
$@：基本上与上面相同。只不过是“$*”返回的是一个字符串，字符串中存在多外空格。 “$@”返回多个字符串。
$#：返回所有脚本参数的个数。
$$ :Shell本身的PID（ProcessID），即当前进程的PID。
$! ：Shell最后运行的后台Process的PID
$- ：使用Set命令设定的Flag一览
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拓展：&lt;br&gt;
Zenity：它是Gnome下的一个项目&lt;/p&gt;
">whiptail指令</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/bu-ding-patchde-zhi-zuo-yu-ying-yong/"" data-c="
          &lt;p&gt;命令简介&lt;br&gt;
用到的两个命令是diff和patch。&lt;/p&gt;
&lt;h3 id=&#34;diff&#34;&gt;diff&lt;/h3&gt;
&lt;p&gt;diff可以比较两个东西，并可同时记录下二者的区别。制作补丁时的一般用法和常见选项为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;diff 【选项】 源文件（夹） 目的文件（夹）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-r&lt;br&gt;
递归。设置后diff会将两个不同版本源代码目录中的所有对应文件全部都进行一次比较，包括子目录文件。&lt;br&gt;
-N&lt;br&gt;
选项确保补丁文件将正确地处理已经创建或删除文件的情况。&lt;br&gt;
-u&lt;br&gt;
输出每个修改前后的3行，也可以用-u5等指定输出更多上下文。&lt;br&gt;
-E, -b, -w, -B, --strip-trailing-cr&lt;br&gt;
忽略各种空白，可参见文档，按需选用。&lt;/p&gt;
&lt;h3 id=&#34;patch&#34;&gt;patch&lt;/h3&gt;
&lt;p&gt;patch的作用则是将diff记录的结果（即补丁）应用到相应文件（夹）上。最常见的用法为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;patch -pNUM &amp;lt;patchfile&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-p Num&lt;br&gt;
忽略几层文件夹，随后详解。&lt;br&gt;
-E&lt;br&gt;
选项说明如果发现了空文件，那么就删除它&lt;br&gt;
-R&lt;br&gt;
取消打过的补丁。&lt;/p&gt;
&lt;p&gt;为了解释 -p 参数，需要看看如下patch文件片段：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--- old/modules/pcitable       Mon Sep 27 11:03:56 1999
+++ new/modules/pcitable       Tue Dec 19 20:05:41 2000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果使用参数 -p0，那就表示从当前目录找一个叫做old的文件夹，再在它下面寻找 modules/pcitable 文件来执行patch操作。&lt;br&gt;
而如果使用参数 -p1，那就表示忽略第一层目录（即不管old），从当前目录寻找 modules 的文件夹，再在它下面找pcitable。&lt;/p&gt;
&lt;p&gt;应用&lt;br&gt;
利用以上命令，处理单个文件补丁的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 产生补丁
diff -uN from-file to-file &amp;gt;to-file.patch
 
# 打补丁
patch -p0 &amp;lt; to-file.patch
 
# 取消补丁
patch -RE -p0 &amp;lt; to-file.patch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对整个文件夹打补丁的情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 产生补丁
diff -uNr  from-docu  to-docu  &amp;gt;to-docu.patch
 
# 打补丁
cd to-docu
patch -p1 &amp;lt; to-docu.patch
 
# 取消补丁
patch -R -p1 &amp;lt;to-docu.patch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，使用版本控制工具时，可以直接用svn diff或git diff生成补丁文件。&lt;/p&gt;
&lt;p&gt;值得一提的是，由于应用补丁时的目标代码和生成补丁时的代码未必相同，打补丁操作可能失败。补丁失败的文件会以.rej结尾，下面命令可以找出所有rej文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;find . -name &#39;*.rej&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;p&gt;patch文件构成&lt;br&gt;
补丁文件里到底存储了哪些信息呢？看看这个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--- test0       2006-08-18 09:12:01.000000000 +0800
+++ test1       2006-08-18 09:13:09.000000000 +0800
@@ -1,3 +1,4 @@
+222222
 111111
-111111
+222222
 111111
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;补丁头&lt;/strong&gt;&lt;br&gt;
补丁头是分别由---/+++开头的两行，用来表示要打补丁的文件。---开头表示旧文件，+++开头表示新文件。&lt;br&gt;
一个补丁文件中的多个补丁&lt;br&gt;
一个补丁文件中可能包含以---/+++开头的很多节，每一节用来打一个补丁。所以在一个补丁文件中可以包含好多个补丁。&lt;br&gt;
&lt;strong&gt;块&lt;/strong&gt;&lt;br&gt;
块是补丁中要修改的地方。它通常由一部分不用修改的东西开始和结束。他们只是用来表示要修改的位置。他们通常以@@开始，结束于另一个块的开始或者一个新的补丁头。&#39;-&#39;后的数字代表该块在旧文件的行号,修改前该块总行数；&#39;+&#39;后的数字代表该块在新文件的行号,修改后该块总行数。&lt;br&gt;
&lt;strong&gt;块的缩进&lt;/strong&gt;&lt;br&gt;
块会缩进一列，而这一列是用来表示这一行是要增加还是要删除的。&lt;br&gt;
&lt;strong&gt;块的第一列&lt;/strong&gt;&lt;br&gt;
+号表示这一行是要加上的。-号表示这一行是要删除的。没有加号也没有减号表示这里只是引用的而不需要修改。&lt;/p&gt;
&lt;h3 id=&#34;实例分析&#34;&gt;实例分析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;单文件补丁&lt;/strong&gt;&lt;br&gt;
设当前目录有文件 test0：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;111111
111111
111111
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和文件test1：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;222222
111111
222222
111111
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用diff创建补丁test1.patch&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;diff -uN test0 test1 &amp;gt; test1.patch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为是单个文件，故不需要 -r 选项。此命令得到如下补丁：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--- test0       2006-08-18 09:12:01.000000000 +0800
+++ test1       2006-08-18 09:13:09.000000000 +0800
@@ -1,3 +1,4 @@
+222222
 111111
-111111
+222222
 111111
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要应用补丁，只需：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ patch -p0 &amp;lt; test1.patch
patching file test0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时test0就和test1一样了。&lt;/p&gt;
&lt;p&gt;如果要取消补丁做出的更改，恢复旧版本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ patch -RE -p0 &amp;lt; test1.patch
patching file test0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;文件夹补丁&lt;/strong&gt;&lt;br&gt;
设有如下环境：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--prj0/
     test0
     prj0name
--prj1/
     test1
     prj1name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;prj0/prj0name内容为如下三行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--------
prj0/prj0name
--------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;prj1/prj1name内容为如下三行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--------
prj1/prj1name
--------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用 diff -uNr 创建补丁，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;diff -uNr prj0 prj1 &amp;gt; prj1.patch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到的patch文件为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;diff -uNr prj0/prj0name prj1/prj0name
--- prj0/prj0name       2006-08-18 09:25:11.000000000 +0800
+++ prj1/prj0name       1970-01-01 08:00:00.000000000 +0800
@@ -1,3 +0,0 @@
---------
-prj0/prj0name
---------
diff -uNr prj0/prj1name prj1/prj1name
--- prj0/prj1name       1970-01-01 08:00:00.000000000 +0800
+++ prj1/prj1name       2006-08-18 09:26:36.000000000 +0800
@@ -0,0 +1,3 @@
+---------
+prj1/prj1name
+---------
diff -uNr prj0/test0 prj1/test0
--- prj0/test0  2006-08-18 09:23:53.000000000 +0800
+++ prj1/test0  1970-01-01 08:00:00.000000000 +0800
@@ -1,3 +0,0 @@
-111111
-111111
-111111
diff -uNr prj0/test1 prj1/test1
--- prj0/test1  1970-01-01 08:00:00.000000000 +0800
+++ prj1/test1  2006-08-18 09:26:00.000000000 +0800
@@ -0,0 +1,4 @@
+222222
+111111
+222222
+111111
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要应用此补丁，则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ls
prj0  prj1  prj1.patch
$ cd prj0
$ patch -p1 &amp;lt; ../prj1.patch
patching file prj0name
patching file prj1name
patching file test0
patching file test1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时可用ls看到打补丁后的结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ls
prj1name  test1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类似的，如果要回滚补丁操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ patch -R -p1 &amp;lt; ../prj1.patch
patching file prj0name
patching file prj1name
patching file test0
patching file test1
$ ls
prj0name  test0
&lt;/code&gt;&lt;/pre&gt;
">补丁(patch)的制作与应用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/makefile/"" data-c="
          &lt;h2 id=&#34;makefile简介&#34;&gt;Makefile简介&lt;/h2&gt;
&lt;h4 id=&#34;makefile是什么&#34;&gt;Makefile是什么?&lt;/h4&gt;
&lt;p&gt;gcc hello.c -o hello&lt;br&gt;
gcc aa.c bb.c cc.c dd.c ...&lt;br&gt;
make工具和Makefile&lt;/p&gt;
&lt;h4 id=&#34;make和makefile是什么关系&#34;&gt;make和Makefile是什么关系？&lt;/h4&gt;
&lt;p&gt;make工具:找出修改过的文件，根据依赖关系，找出受影响的相关文件，最后按照规则单独编译这些文件。&lt;br&gt;
Makefile文件:记录依赖关系和编译规则。&lt;/p&gt;
&lt;h4 id=&#34;必须要学精makefile吗&#34;&gt;必须要学精Makefile吗?&lt;/h4&gt;
&lt;h4 id=&#34;怎么学习makefile&#34;&gt;怎么学习Makefile?&lt;/h4&gt;
&lt;p&gt;Makefile的本质:无论多么复杂的语法，都是为了更好地解决项目文件之间的依赖关系。&lt;/p&gt;
&lt;h2 id=&#34;makefile三要素&#34;&gt;Makefile三要素&lt;/h2&gt;
&lt;h3 id=&#34;makefile三要素是什么&#34;&gt;Makefile三要素是什么?&lt;/h3&gt;
&lt;p&gt;目标、依赖、命令&lt;/p&gt;
&lt;h3 id=&#34;怎么描述三要素的关系&#34;&gt;怎么描述三要素的关系？&lt;/h3&gt;
&lt;p&gt;目标：依赖的文件或者是其他目标&lt;br&gt;
&lt;tab&gt;命令1&lt;br&gt;
&lt;tab&gt;命令2&lt;br&gt;
&lt;tab&gt;...&lt;/p&gt;
&lt;h3 id=&#34;实验演示&#34;&gt;实验演示&lt;/h3&gt;
&lt;p&gt;.PHONY:可以指定伪目标&lt;/p&gt;
&lt;h2 id=&#34;引入makefile管理项目&#34;&gt;引入Makefile管理项目&lt;/h2&gt;
&lt;h3 id=&#34;makefile的变量-模式匹配&#34;&gt;Makefile的变量、模式匹配&lt;/h3&gt;
&lt;h3 id=&#34;变量&#34;&gt;变量&lt;/h3&gt;
&lt;h4 id=&#34;系统变量&#34;&gt;系统变量&lt;/h4&gt;
&lt;h4 id=&#34;自定义变量&#34;&gt;自定义变量&lt;/h4&gt;
&lt;p&gt;=，延迟赋值&lt;br&gt;
:=, 立即赋值&lt;br&gt;
?=,空赋值&lt;br&gt;
+=，追加赋值&lt;/p&gt;
&lt;h4 id=&#34;自动化变量&#34;&gt;自动化变量&lt;/h4&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;第&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;一&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;个&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;依&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;赖&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;文&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;件&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;&amp;lt;:第一个依赖文件
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;第&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;一&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;个&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;依&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;赖&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;文&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;^：全部的依赖文件&lt;br&gt;
$@:目标&lt;/p&gt;
&lt;h3 id=&#34;模式匹配&#34;&gt;模式匹配&lt;/h3&gt;
&lt;p&gt;%:匹配任意多个非空字符&lt;br&gt;
shell：*通配符&lt;/p&gt;
&lt;h3 id=&#34;默认规则&#34;&gt;默认规则&lt;/h3&gt;
&lt;p&gt;.o文件默认使用.c文件来进行编译&lt;/p&gt;
&lt;h2 id=&#34;makefile条件分支&#34;&gt;Makefile条件分支&lt;/h2&gt;
&lt;h4 id=&#34;条件分支&#34;&gt;条件分支&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;ifeq (var1,var2)
...
else
...
endif
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ifneq (var1,var2)
...
else
...
endif
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;makefile的常用函数&#34;&gt;Makefile的常用函数&lt;/h2&gt;
&lt;p&gt;Makefie官方手册:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.gnu.org/software/make/manual&#34;&gt;https://www.gnu.org/software/make/manual&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;patsubst：&lt;/p&gt;
&lt;p&gt;notdir：&lt;/p&gt;
&lt;p&gt;wildcard：&lt;/p&gt;
&lt;p&gt;foreach：&lt;/p&gt;
&lt;h2 id=&#34;makefile解决头文件依赖&#34;&gt;Makefile解决头文件依赖&lt;/h2&gt;
&lt;p&gt;1、写一个头文件，并把头文件添加到编译器的头文件路径中。&lt;/p&gt;
&lt;p&gt;gcc -I +&amp;quot;头文件&amp;quot;&lt;/p&gt;
&lt;p&gt;2、实时检查头文件的更新情况，一旦头文件发生变化，应该要重新编译所有相关文件。&lt;/p&gt;
&lt;p&gt;gcc -MM&lt;/p&gt;
">Makefile</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/qemu-shi-yong/"" data-c="
          ">qemu使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/linux-qu-dong-kai-fa/"" data-c="
          &lt;p&gt;篇章一：&lt;/p&gt;
&lt;h2 id=&#34;一切皆文件&#34;&gt;一切皆文件&lt;/h2&gt;
&lt;h4 id=&#34;linux内核&#34;&gt;Linux内核&lt;/h4&gt;
&lt;p&gt;屏蔽硬件区别，把所有的硬件设备抽象成文件，提供统一的接口给用户使用。&lt;/p&gt;
&lt;h4 id=&#34;虚拟文件系统&#34;&gt;虚拟文件系统&lt;/h4&gt;
&lt;p&gt;抽象层，对文件的访问实际上使对抽象层的访问。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象对象：封装了底层读写细节，使用c语言的多态来实现具体文件系统系统的接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;普通文件系统&#34;&gt;普通文件系统：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;ext4&lt;/li&gt;
&lt;li&gt;fat32&lt;/li&gt;
&lt;li&gt;ubifs&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;特殊文件系统&#34;&gt;特殊文件系统：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;进程文件系统：procfs，挂载在/proc，存放进程相关信息，任务管理器。&lt;/li&gt;
&lt;li&gt;设备文件系统：devfs，挂载在/dev。存放硬件操作接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文件描述符和打开模式&#34;&gt;文件描述符和打开模式&lt;/h2&gt;
&lt;h4 id=&#34;系统io编程&#34;&gt;系统IO编程&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;open&lt;/li&gt;
&lt;li&gt;write&lt;/li&gt;
&lt;li&gt;read&lt;/li&gt;
&lt;li&gt;lseek&lt;/li&gt;
&lt;li&gt;close&lt;br&gt;
伪代码:&lt;br&gt;
int fd;&lt;br&gt;
fd = open(filename,flags,mode);&lt;br&gt;
lseek(fd,offset,whence);&lt;br&gt;
write(fd,buf,write_len);&lt;br&gt;
read(fd,buf,read_len)&lt;br&gt;
close(fd);&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;文件描述符&#34;&gt;文件描述符&lt;/h5&gt;
&lt;p&gt;特殊的索引&lt;br&gt;
实际上就是进程中file_struct结构体成员fd_array的数组下标&lt;/p&gt;
&lt;h4 id=&#34;文件打开模式&#34;&gt;文件打开模式&lt;/h4&gt;
&lt;p&gt;主模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O_RDONLY:只读模式&lt;/li&gt;
&lt;li&gt;O_WRONLY:只写模式&lt;/li&gt;
&lt;li&gt;O_RDWR:读写，模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;副模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O_CREAT:当文件不存在，需要去创建文件&lt;/li&gt;
&lt;li&gt;O_APPEND:追加模式&lt;/li&gt;
&lt;li&gt;O_DIRECT:直接IO模式&lt;/li&gt;
&lt;li&gt;O_SYNC:同步模式&lt;/li&gt;
&lt;li&gt;O_NOBLOCK:非阻塞模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;进程&#34;&gt;进程&lt;/h4&gt;
&lt;p&gt;每个程序本质上就是一个进程&lt;/p&gt;
&lt;h4 id=&#34;标准io编程&#34;&gt;标准IO编程&lt;/h4&gt;
&lt;h2 id=&#34;open_close函数&#34;&gt;open_close函数&lt;/h2&gt;
&lt;h3 id=&#34;open函数&#34;&gt;OPEN函数&lt;/h3&gt;
&lt;p&gt;头文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当文件存在时&lt;pre&gt;&lt;code&gt;int open(const char* pathname,int flags)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;当文件不存在时&lt;pre&gt;&lt;code&gt;int open (const char* pathname,int flags,int perms)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回值&lt;br&gt;
成功：文件描述符&lt;br&gt;
失败：-1&lt;/p&gt;
&lt;h3 id=&#34;close函数&#34;&gt;CLOSE函数&lt;/h3&gt;
&lt;p&gt;头文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int close(int fd)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回值：&lt;br&gt;
成功：0&lt;br&gt;
失败：-1&lt;/p&gt;
&lt;h2 id=&#34;lseek函数&#34;&gt;lseek函数&lt;/h2&gt;
&lt;h4 id=&#34;lseek函数-2&#34;&gt;lseek函数&lt;/h4&gt;
&lt;h5 id=&#34;头文件&#34;&gt;头文件&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;函数原型&#34;&gt;函数原型&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;ssize_t read(int fd,void *buff,size_t count)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;返回值&#34;&gt;返回值&lt;/h5&gt;
&lt;p&gt;成功：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;count：成功读取全部字节&lt;/li&gt;
&lt;li&gt;0~count:
&lt;ul&gt;
&lt;li&gt;剩余文件长度小于count&lt;/li&gt;
&lt;li&gt;读取期间被异步信号打断&lt;br&gt;
失败：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;-1，读取错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;write函数&#34;&gt;write函数&lt;/h4&gt;
&lt;h5 id=&#34;头文件-2&#34;&gt;头文件&lt;/h5&gt;
&lt;p&gt;同read函数&lt;/p&gt;
&lt;h5 id=&#34;函数原型-2&#34;&gt;函数原型&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;ssize_t write(int fd,void *buff,size_t count)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;返回值-2&#34;&gt;返回值&lt;/h5&gt;
&lt;p&gt;成功：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;count：成功写入全部字节&lt;/li&gt;
&lt;li&gt;0~count:
&lt;ul&gt;
&lt;li&gt;写入期间被异步信号打断&lt;br&gt;
失败：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;-1，读取错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;复制普通文件小实验&#34;&gt;复制普通文件小实验&lt;/h3&gt;
&lt;p&gt;1、打开要复制的文件&lt;br&gt;
2、创建新的文件&lt;br&gt;
3、把源文件内容读到缓冲区，把缓冲区内容写入新文件&lt;br&gt;
4、循坏执行第三步，直到读取的字节数量为0，退出循坏。&lt;br&gt;
5、关闭打开的文件&lt;/p&gt;
&lt;h2 id=&#34;lseek和sync函数&#34;&gt;lseek和sync函数&lt;/h2&gt;
&lt;h4 id=&#34;lseek函数-3&#34;&gt;lseek函数&lt;/h4&gt;
&lt;h5 id=&#34;功能&#34;&gt;功能&lt;/h5&gt;
&lt;p&gt;设置文件读写位置&lt;/p&gt;
&lt;h5 id=&#34;头文件-3&#34;&gt;头文件&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;函数原型-3&#34;&gt;函数原型&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;off_t lseek(int fd,off_t offset,int whence)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;若whence为SEEK_SET，基准点为文件开头&lt;/li&gt;
&lt;li&gt;若whence为SEEK_CUR，基准点为当前位置&lt;/li&gt;
&lt;li&gt;若whence为SEEK_END，基准点为文件末尾&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;返回值-3&#34;&gt;返回值&lt;/h5&gt;
&lt;p&gt;成功：文件偏移位置值&lt;br&gt;
失败：-1&lt;/p&gt;
&lt;h4 id=&#34;sync函数&#34;&gt;sync函数&lt;/h4&gt;
&lt;h5 id=&#34;页缓存和回写&#34;&gt;页缓存和回写&lt;/h5&gt;
&lt;h5 id=&#34;功能-2&#34;&gt;功能&lt;/h5&gt;
&lt;p&gt;强制把修改过的页缓存区数据写入磁盘&lt;/p&gt;
&lt;h5 id=&#34;头文件-4&#34;&gt;头文件&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;函数原型-4&#34;&gt;函数原型&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;void sync(void);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;返回值-4&#34;&gt;返回值&lt;/h5&gt;
&lt;p&gt;无&lt;/p&gt;
&lt;h2 id=&#34;标准io函数&#34;&gt;标准IO函数&lt;/h2&gt;
&lt;p&gt;C标准库实现了一个IO缓存区&lt;/p&gt;
&lt;h4 id=&#34;常见标准io函数&#34;&gt;常见标准IO函数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;fopen&lt;/li&gt;
&lt;li&gt;fclose&lt;/li&gt;
&lt;li&gt;fread&lt;/li&gt;
&lt;li&gt;fwrite&lt;/li&gt;
&lt;li&gt;fseek&lt;/li&gt;
&lt;li&gt;fflush&lt;br&gt;
强制把IO缓存区的数据写入到页缓存区&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;文件io五大模式&#34;&gt;文件IO五大模式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;阻塞模式&lt;/li&gt;
&lt;li&gt;非阻塞模式&lt;/li&gt;
&lt;li&gt;IO多路复用&lt;/li&gt;
&lt;li&gt;异步IO&lt;/li&gt;
&lt;li&gt;信号驱动IO&lt;/li&gt;
&lt;/ul&gt;
">linux驱动开发</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/overlayfs-xue-xi/"" data-c="
          ">overlayfs学习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/littlefs-wen-jian-xi-tong-xue-xi/"" data-c="
          &lt;p&gt;相信大家对于文件系统都多少了解点，较为熟悉的文件系统FATfs文件系统啦~~&lt;br&gt;
而FATfs文件系统作为比较成熟的文件也已经在项目中使用的很多了，那还有其他的文件系统吗？&lt;br&gt;
回答是当然有的，例如LittleFs、SPIFFS等&lt;br&gt;
首先说明一下littlefs文件系统本人已在实际项目中使用过了，感觉还不错&lt;br&gt;
关于Littlefs和FATfs的对比如下：&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1650221615661.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1650221640392.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
同时RTOS文件系统对比：LittleFS VS SPIFFS:&lt;br&gt;
https://www.cnblogs.com/gmpy/p/12498999.html&lt;/p&gt;
&lt;p&gt;当然我们还是要先讲一下这个文件的一些简介&lt;br&gt;
详细介绍：https://os.mbed.com/blog/entry/littlefs-high-integrity-embedded-fs/&lt;br&gt;
LittleFs Github: https://github.com/ARMmbed/littlefs&lt;/p&gt;
&lt;p&gt;LittleFs是一个小型的Flash文件系统，它结合日志结构（log-structured）文件系统和COW（copy-on-write）文件系统的思想，以日志结构存储元数据，以COW结构存储数据。这种特殊的存储方式，使LittleFS具有强大的掉电恢复能力（power-loss resilience)。分配COW数据块时LittleFS采用了名为统计损耗均衡的动态损耗均衡算法，使Flash设备的寿命得到有效保障。同时LittleFS针对资源紧缺的小型设备进行设计，具有极其有限的ROM和RAM占用，并且所有RAM的使用都通过一个可配置的固定大小缓冲区进行分配，不会随文件系统的扩大占据更多的系统资源。当在一个资源非常紧缺的小型设备上，寻找一个具有掉电恢复能力并支持损耗均衡的Flash文件系统时，LittleFS是一个比较好的选择。&lt;/p&gt;
&lt;p&gt;LittleFs设计之初的重点特性是：&lt;br&gt;
（1）低资源消耗----物联网设备受到ROM和RAM的限制。 小的足迹可以省钱；&lt;br&gt;
（2）掉电保护------它需要强有力的保证文件系统保持一致，并将数据刷新到底层存储；&lt;br&gt;
（3）擦写均衡------通常存储支持每个块的有限数量的擦除，因此利用整个存储设备对可靠性非常重要.&lt;br&gt;
1.掉电保护&lt;br&gt;
最经典的掉电保护方法有两种，一种是使用日志，一种是通过COW方式。lfs结合了两种方法，并优化了两种方案的缺点，提供了一套掉电保护策略。&lt;br&gt;
1.1.日志方式&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1650220654535.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
具体步骤为：&lt;br&gt;
（1） 写入数据之前，先在日志区存储开始标志，记录要写入的数据位置和大小；&lt;br&gt;
（2） 待写入的数据写入日志区；&lt;br&gt;
（3） 待写入的数据写入数据区；&lt;br&gt;
（4） 写入完成之后，在日志区记录结束标志。&lt;br&gt;
模拟掉电场景：&lt;br&gt;
（1） 步骤1完成，步骤2没有完成；重启之后，保持原来的数据，日志无效；&lt;br&gt;
（2） 步骤1，2完成了，步骤3没有完成，尝试把步骤2的数据写入到数据区；&lt;br&gt;
（3） 步骤1,2,3完成了，步骤4没有完成，同样尝试把步骤2的数据写入到数据区；&lt;br&gt;
1.2.Cow机制&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1650220735223.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
具体步骤为：&lt;br&gt;
（1） 想更新节点F的数据，先申请一个新的节点，把F的旧数据拷贝过去，然后更新新的数据；&lt;br&gt;
（2） 把父节点的指针指向新的节点，去掉旧节点的指针。&lt;br&gt;
模拟掉电场景：&lt;br&gt;
（1）步骤（1）完成了，步骤（2）没有完成，则使用旧的数据，新的节点变成孤儿节点。&lt;br&gt;
1.3 lfs掉电保护&lt;br&gt;
lfs结合了日志方式和COW机制两种方式进行掉电保护，并且优化了两种方案。&lt;br&gt;
前面谈过文件系统三要素，超级块，inode，以及数据。对应lfs来说，他把超级块以及inode通过日志的方式存储，两种采用统一的存储结构，后文称两者为元数据；普通数据则采用cow的方式存储，采用czt逆序链表的方式。&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1650220823675.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
1.3.1 元数据的存储&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1650221042667.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
元数据（对应root，dir）采用双block的方式存储，互为备份，每个block都有一个revision序号，值越大，表示block的数据越新，每个block默认可以存储最多0xff个文件的数据，如果超过这个值，则需要compact（压缩）。&lt;br&gt;
Compact是干什么呢？ 即当数据的大小大于某个值的时候，把数据整合，剔除同一个id的旧的数据，然后写入到备份block里面。&lt;br&gt;
在compact的过程中，如果发现整合的数据还是大于某个值，怎么办呢？需要split（分片）。&lt;/p&gt;
&lt;p&gt;1.3.2 普通数据的存储（CTZ）&lt;br&gt;
Lfs的数据采用ctz链表的方式逆向管理，这与传统的文件系统有比较大的差别。具体对比见下图所示。&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1650221084995.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
传统的方式添加数据，需要建立旧的数据到新的数据的索引。这样做有两个弊端：&lt;br&gt;
（1） 当数据特别多的时候，这样一个个的索引过去查找，比较费时间。&lt;br&gt;
（2） 当使用cow机制的时候，在文件后面每增加一次数据，需要把所有的索引都重新建立一个，这样带来的性能损耗特别大。&lt;br&gt;
为了解决这两个问题，lfs采用了下面的管理方式。&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1650221108856.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
（1） 采用逆向的指针，这样常规的追加数据，不需要额外的开销来重新建立所有的索引；&lt;br&gt;
（2） 每个偶数block有多个指针，指向更远的数据，这样可以在检索的时候加快速度。&lt;br&gt;
指针的建立采用了CTZ(二进制中最后一个不为0的位，其右边0的个数)的方式。大概原理就是，block N 如果是一个能被 2^X整除的数，那么他就存在指向N – 2^X的指针，指针的数目为ctz(N)+1。&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1650221138444.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
从上表可以看出，block 2多一个指向0的指针，block 4多一个指向0,2的指针。&lt;br&gt;
咱们已经知道了实际数据（对应file）采用czt list的方式存储，最新的数据block指向次新的数据block（这个是为了提高COW的效率）。&lt;br&gt;
一次常规更新数据的过程大概为（实际比这个复杂很多，需要考虑cache、孤儿、crc等问题）：&lt;br&gt;
（1） 往file文件中写入数据；&lt;br&gt;
（2） 申请一个新的block，并且把file文件最后一个block的数据复制到新的block，并追加要写入的数据；&lt;br&gt;
（3） 更新新block的czt list（在block的头部会占用一定的4字节倍数的字节来记录索引，这个czt list只是用来fseek的加快速度）；&lt;br&gt;
（4） 文件fclose的时候，更新对应的元数据信息到父节点中。&lt;br&gt;
掉电保护的具体场景：&lt;br&gt;
1.步骤（1），（2），（3）完成了，但是（4）没有完成。因为索引还没有建立起来，数据虽然写入了，但是没有人知道，文件系统会丢失最新的数据，保留修改之前的数据。&lt;br&gt;
2.步骤（4）过程中掉电了。步骤（4）是更新元数据，元数据采用了主备的方式，并且采取了如下的格式：&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1650221166250.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
正常的提交流程为：&lt;br&gt;
（1）提交tag；&lt;br&gt;
（2）提交data；&lt;br&gt;
（3）提交crc。&lt;br&gt;
当tag和data提交了，但是CRC没有提交的时候，crc就会校验失败，这个时候前面crc校验通过的部分，就会被relocate到一个新的块，这样由于断电导致的数据异常，则回退成功。注意：crc校验的时机，在提交一个新的commit到对应的元数据的时候。&lt;/p&gt;
&lt;p&gt;2 擦写均衡&lt;br&gt;
了解擦写均衡之前，先需要知道littlefs是怎么管理物理block的，怎么才能申请到一个空闲的block。&lt;br&gt;
2.1 Block管理&lt;br&gt;
为了节省内容，Littlefs对空闲block的管理采用了滑窗方式，滑窗的大小是可以配置，默认是32bit，对应32个block的使用情况。&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1650221239202.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当文件系统需要申请一个空闲的block的时候，从lookahead中寻找没有置位的block，申请成功，则给对应的block位置1。当当前的窗口中的所有block都被占用的时候，就需要滑动窗口了，一次性滑动窗口大小的距离，即默认一次滑动32个block。&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1650221263085.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当窗口滑动了之后，lookahead中又有了新的空闲的block可以申请。&lt;br&gt;
问题来了，怎么定义一个block是不是空闲的呢？&lt;br&gt;
一片flash的总的block是有限的，假设其序号从0-&amp;gt;N，lookahead对应的block范围是I-&amp;gt;J，Littlefs会通过lfs_fs_traverse遍历所有使用到的block，如果这个block在I-&amp;gt;J之间，则说明block被使用了，否则就是空闲的。&lt;br&gt;
2.2 擦写均衡的实现&lt;br&gt;
通过前面的滑窗机制，可以一定程度上的避免每次操作到的都是同一个片区的block。但是这还不够，因为每次启动的时候，滑窗都是从block0开始滑动的，这个会导致前面的block使用频率高于后面的block。所以，我们需要找到办法，让每次启动的时候，滑窗的位置都是随机的，极致的随机，就是平均了。&lt;br&gt;
为此，littlefs使用了crc作为随机数，再通过简单的运算，得到了滑窗启动的时候的起始位置。&lt;br&gt;
问题又来了，crc哪儿来的，干什么的？&lt;br&gt;
Crc就是元数据提交的终结符号，用来校验提交是不是正确的，littlefs借用了crc之间相互异或带来的不确定性来作为滑窗的启动地址，一定程度上复用了现有的机制达到了随机的目的。&lt;/p&gt;
&lt;p&gt;3 文件读写&lt;br&gt;
写入流程：&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1650221307128.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
读取流程：&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1650221323450.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;相关移植过程如下：&lt;/p&gt;
">LittleFs文件系统学习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/remoteproc-kuang-jia/"" data-c="
          &lt;p&gt;Remoteproc(Remote Processor Framework)，主要作用就是对远程处理器的生命周期进行管理，即启动、停止远程处理器。&lt;br&gt;
以STM32MP157为例，Cortex-A内核先启动，然后使用Linux RemoteProc框架进行加载Cortex-M4固件，启动M4内核。&lt;br&gt;
ST官方提供的内核已经默认配置了Remoteproc驱动，进入系统后，首先将要运行的M4固件放在/lib/firmware/目录下，然后将固件名字写到/sys/class/remoteproc/remoteproc0/firmware，再操作/sys/class/remoteproc/remoteproc0/state启动、停止M4处理器。&lt;/p&gt;
">Remoteproc框架</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/rpmsg-xue-xi/"" data-c="
          &lt;p&gt;RPMsg（Remote Processor Messaging）是一种基于virtio的消息传递总线，允许内核驱动程序与系统上可用的远程处理器进行通信。如果需要，驱动程序可以暴露适当的用户空间接口。每个RPMsg设备都是与远程处理器的通信通道（因此RPMsg设备称为通道）。通道由文本名称标识，并具有本地（“source”）RPMsg地址和远程（“destination”）RPMsg 地址。&lt;br&gt;
如下图所示，消息在端点之间通过双向无连接通信通道传递。iMX6 SoloX的Core 0是ARM Cortex®-A9，而Core 1是ARM Cortex®-M4&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1649608633673.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
A9 Linux配置&lt;br&gt;
Source Code和配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drivers/rpmsg/virtio_rpmsg_bus.c
drivers/rpmsg/imx_rpmsg.c
drivers/rpmsg/imx_rpmsg_pingpong.c
drivers/rpmsg/imx_rpmsg_tty.c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里virtio_rpmsg_bus.c是通用代码，imx_rpmsg.c是平台相关代码，imx_rpmsg_pingpong.c是pingpong测试代码，imx_rpmsg_tty.c是rpmsg tty驱动代码。这部分代码一般不需要改动，只需要在内核的defconfig文件中做相关配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;For RPMSG pingpong test
Symbol: IMX_RPMSG_PINGPONG [=m]
Type : tristate
Prompt: IMX RPMSG pingpong driver
	Location:
		-&amp;gt; Device Drivers
			-&amp;gt; Rpmsg drivers
				-&amp;gt; RPMSG bus driver (RPMSG [=y])
For RPMSG TTY driver
Symbol: IMX_RPMSG_TTY [=m]
Type : tristate
Prompt: IMX RPMSG tty driver
	Location:
		-&amp;gt; Device Drivers
			-&amp;gt; Rpmsg drivers
				-&amp;gt; RPMSG bus driver (RPMSG [=y])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DTS文件配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  reserved-memory {                                       
      m4_reserved {             
          reg= &amp;lt;0x8FF00000 0xF0000&amp;gt;;
          no-map;
      };          
          
      rpmsg_reserved {                                    
          reg= &amp;lt;0x8FFF0000 0x10000&amp;gt;;
          no-map;           
      };      
  };
      
  &amp;amp;rpmsg{
      vdev-nums = &amp;lt;1&amp;gt;;
      reg = &amp;lt;0x8FFF0000 0x10000&amp;gt;;
      status = &amp;quot;okay&amp;quot;;
  };    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里给M4预留了0x8FF00000至0x8FFF0000的内存空间，这里需要和u-boot加载M4的地址保持一致；另外给RPMsg预留了0x8FFF0000至0x90000000的共享内存空间（也就是通信通道），这里需要和M4 FreeRTOS中给RPMsg的配置保持一致。&lt;/p&gt;
&lt;p&gt;M4 FreeRTOS配置&lt;br&gt;
在imx6sx_m4/platform_info.c文件里面配置RPMsg的共享内存空间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  //256M
  #define VRING0_BASE                       0x8FFF0000
  #define VRING1_BASE                       0x8FFF8000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里共享内存的地址空间也是0x8FFF0000至0x90000000，总共64KB大小。&lt;/p&gt;
&lt;p&gt;运行RPMsg测试程序&lt;br&gt;
首先使用M4 FreeRTOS源码构建rpmsg_pingpong_freertos_example.bin测试程序，然后在u-boot命令行使用tftp命令在内存0x8FF00000处运行它&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;U-Boot&amp;gt; tftpboot 0x8FF00000 rpmsg_pingpong_freertos_example.bin
U-Boot&amp;gt; dcache flush
U-Boot&amp;gt; bootaux 0x8FF00000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着在内存里运行Linux和ramdisk系统&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;U-Boot&amp;gt; tftpboot 0x80000000 uImage
U-Boot&amp;gt; tftpboot 0x82000000 imx6sx.dtb
U-Boot&amp;gt; tftpboot 0x83800000 core-image.cpio.gz.u-boot
U-Boot&amp;gt; setenv bootargs &#39;console=ttymxc0,115200n8 root=/dev/ram0 rw&#39;
U-Boot&amp;gt; bootm 0x80000000 0x83800000 0x82000000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进入系统后，使用insmod imx_rpmsg_tty.ko运行测试程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ insmod imx_rpmsg_tty.ko
$ /unit_tests/mxc_mcc_tty_test.out /dev/ttyRPMSG 115200 R 100 1000 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Linux系统的log&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insmod imx_rpmsg_tty.ko
Install rpmsg tty driver!
echo deadbeaf &amp;gt; /dev/ttyRPMSG
imx_rpmsg_tty rpmsg0: msg(&amp;lt;- src 0x1) deadbeaf len 8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;FreeRTOS的log&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RPMSG PingPong FreeRTOS RTOS API Demo...
RPMSG Init as Remote
Service handshake is done, M4 has setup a rpmsg channel [0 ---&amp;gt; 1024]
len:4   dst:1024        src:1024
Get Data From Master Side : deadbeaf
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
">RPMsg框架</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/gige-xie-yi/"" data-c="
          ">gige协议</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/shi-jue-suan-fa/"" data-c="
          ">视觉算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/ros-kai-fa/"" data-c="
          ">ROS开发</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/pai-xu-suan-fa/"" data-c="
          &lt;p&gt;&lt;strong&gt;冒泡：&lt;/strong&gt;&lt;br&gt;
1.比较相邻的元素。如果第一个比第二个大，就交换它们两个&lt;br&gt;
2: 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数&lt;br&gt;
（先确定最大的数）对比次数逐级减小&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://easyzoom.github.io/post-images/1649607423509.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt; void BubbleSort(int *arr, int size)    
{    
	    int i, j, tmp;    
	    for (i = 0; i &amp;lt; size - 1; i++) 
        {    
	        for (j = 0; j &amp;lt; size - i - 1; j++) 
            {    
	            if (arr[j] &amp;gt; arr[j+1])
                 {    
	                tmp = arr[j];    
	                arr[j] = arr[j+1];    
	                arr[j+1] = tmp;    
	            }    
    	     }    
	    }    
}   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;选择排序：&lt;/strong&gt;&lt;br&gt;
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置&lt;br&gt;
再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。&lt;br&gt;
以此类推，直到所有元素均排序完毕&lt;/p&gt;
&lt;p&gt;复杂程度&lt;br&gt;
时间复杂度O(n^2)         空间复杂度O(1)&lt;br&gt;
空间复杂度O(1)&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1649607985939.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void SelectionSort(int *arr, int size)  
{  
	    int i, j, k, tmp;  
	    for (i = 0; i &amp;lt; size - 1; i++) {  
	        k = i;  
	        for (j = i + 1; j &amp;lt; size; j++) {  
	            if (arr[j] &amp;lt; arr[k]) {  
	                k = j;  
	            }  
	        }  
	        tmp = arr[k];  
	        arr[k] = arr[i];  
	        arr[i] = tmp;  
	    }  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;插入排序：&lt;/strong&gt;&lt;br&gt;
步骤1: 从第一个元素开始，该元素可以认为已经被排序；&lt;br&gt;
步骤2: 取出下一个元素，在已经排序的元素序列中从后向前扫描；&lt;br&gt;
步骤3: 如果该元素（已排序）大于新元素，将该元素移到下一位置；&lt;br&gt;
步骤4: 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；&lt;br&gt;
步骤5: 将新元素插入到该位置后；&lt;br&gt;
步骤6: 重复步骤2~5。&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1649607890961.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void InsertionSort(int *arr, int size)      
{      
	    int i, j, tmp;      
	    for (i = 1; i &amp;lt; size; i++) 
        {      
	        if (arr[i] &amp;lt; arr[i-1])
             {      
	            tmp = arr[i];      
.	            for (j = i - 1; j &amp;gt;= 0 &amp;amp;&amp;amp; arr[j] &amp;gt; tmp; j--)
                {    
	                arr[j+1] = arr[j];      
	            }    
                arr[j+1] = tmp;      
             } 
	    }      
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;希尔排序：&lt;/strong&gt;&lt;br&gt;
将数据组先切成连个数组数组1的和数组2的数据两两成为一组先进行大小排序&lt;br&gt;
然后再切成更大的分组在进行插入排序（数组数量以上次的数组数量一次递减）&lt;br&gt;
直到将组切为一个完整大数据大小&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1649608055668.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void ShellSort(int *arr, int size)    
2.	{    
3.	    int i, j, tmp, increment;    
4.	    for (increment = size/ 2; increment &amp;gt; 0; increment /= 2) {      
5.	        for (i = increment; i &amp;lt; size; i++) {    
6.	            tmp = arr[i];    
7.	            for (j = i - increment; j &amp;gt;= 0 &amp;amp;&amp;amp; tmp &amp;lt; arr[j]; j -= increment) {    
8.	                arr[j + increment] = arr[j];    
9.	            }    
10.	            arr[j + increment] = tmp;  
11.	        }    
12.	    }    
13.	}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;归并排序：&lt;/strong&gt;&lt;br&gt;
步骤1：把长度为n的输入序列分成两个长度为n/2的子序列；&lt;br&gt;
步骤2：对这两个子序列分别采用归并排序；&lt;br&gt;
步骤3：将两个排序好的子序列合并成一个最终的排序序列。&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1649608106519.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define MAXSIZE 100    
2.	   
3.	void Merge(int *SR, int *TR, int i, int middle, int rightend)   
4.	{  
5.	    int j, k, l;    
6.	    for (k = i, j = middle + 1; i &amp;lt;= middle &amp;amp;&amp;amp; j &amp;lt;= rightend; k++) {    
7.	        if (SR[i] &amp;lt; SR[j]) {  
8.	            TR[k] = SR[i++];  
9.	        } else {   
10.	            TR[k] = SR[j++];  
11.	        }    
12.	    }    
13.	    if (i &amp;lt;= middle) {  
14.	        for (l = 0; l &amp;lt;= middle - i; l++) {  
15.	            TR[k + l] = SR[i + l];  
16.	        }    
17.	    }    
18.	    if (j &amp;lt;= rightend) {  
19.	        for (l = 0; l &amp;lt;= rightend - j; l++) {  
20.	            TR[k + l] = SR[j + l];    
21.	        }  
22.	    }    
23.	}    
24.	    
25.	void MergeSort(int *SR, int *TR1, int s, int t)   
26.	{    
27.	    int middle;    
28.	    int TR2[MAXSIZE + 1];    
29.	    if (s == t) {  
30.	        TR1[s] = SR[s];   
31.	    } else {    
32.	        middle = (s + t) / 2;  
33.	        MergeSort(SR, TR2, s, middle);  
34.	        MergeSort(SR, TR2, middle + 1, t);  
35.	        Merge(TR2, TR1, s, middle, t);  
36.	    }    
37.	}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;快速排序：（不断前后交替查找中位值）&lt;/strong&gt;*&lt;br&gt;
步骤1：从数列中挑出一个元素，称为 “基准”（pivot ）；&lt;br&gt;
步骤2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；&lt;br&gt;
步骤3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1649608152216.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void QuickSort(int *arr, int maxlen, int begin, int end)    
2.	{    
3.	    int i, j;    
4.	    if (begin &amp;lt; end) {    
5.	        i = begin + 1;    
6.	        j = end;          
7.	        while (i &amp;lt; j) {    
8.	            if(arr[i] &amp;gt; arr[begin]) {    
9.	                swap(&amp;amp;arr[i], &amp;amp;arr[j]);   
10.	                j--;    
11.	            } else {    
12.	                i++;   
13.	            }    
14.	        }    
15.	        if (arr[i] &amp;gt;= arr[begin]) {    
16.	            i--;    
17.	        }    
18.	        swap(&amp;amp;arr[begin], &amp;amp;arr[i]);        
19.	        QuickSort(arr, maxlen, begin, i);    
20.	        QuickSort(arr, maxlen, j, end);    
21.	    }    
22.	}    
23.	   
24.	void swap(int *a, int *b)      
25.	{    
26.	    int temp;    
27.	    temp = *a;    
28.	    *a = *b;    
29.	    *b = temp;    
30.	}    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;堆排序：&lt;/strong&gt;&lt;br&gt;
步骤1：将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；&lt;br&gt;
步骤2：将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&amp;lt;=R[n]；&lt;br&gt;
步骤3：由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1649608191045.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void Heapify(int *arr, int m, int size)    
2.	{    
3.	    int i, tmp;    
4.	    tmp = arr[m];    
5.	    for (i = 2 * m; i &amp;lt;= size; i *= 2) {    
6.	        if (i + 1 &amp;lt;= size &amp;amp;&amp;amp; arr[i] &amp;lt; arr[i+1]) {    
7.	            i++;    
8.	        }    
9.	        if (arr[i] &amp;lt; tmp) {    
10.	            break;    
11.	        }    
12.	        arr[m] = arr[i];    
13.	        m = i;    
14.	    }    
15.	    arr[m] = tmp;    
16.	}    
17.	    
18.	void BulidHeap(int *arr, int size)  
19.	{    
20.	    int i;    
21.	    for (i = n / 2; i &amp;gt; 0; i--) {    
22.	        Heapify(arr, i, size);    
23.	    }    
24.	}    
25.	      
26.	void swap(int *arr, int i, int j)    
27.	{    
28.	    int tmp;    
29.	    tmp = arr[i];    
30.	    arr[i] = arr[j];    
31.	    arr[j] = tmp;    
32.	}    
33.	    
34.	void HeapSort(int *arr, int size)    
35.	{    
36.	    int i;    
37.	    BulidHeap(arr, size);    
38.	    for (i = size; i &amp;gt; 1; i--) {    
39.	        swap(arr, 1, i);  
40.	        Heapify(arr, 1, i - 1);  
41.	    }    
42.	}    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;计数排序：&lt;/strong&gt;&lt;br&gt;
步骤1：找出待排序的数组中最大和最小的元素；&lt;br&gt;
步骤2：统计数组中每个值为i的元素出现的次数，存入数组C的第i项；&lt;br&gt;
步骤3：对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；&lt;br&gt;
步骤4：反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1649608242802.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.	void CountingSort(int *A, int *B, int n, int k)    
2.	  
3.	 int *C = (int *)malloc(sizeof(int) * (k + 1));    
4.	 int i;    
5.	 for (i = 0; i &amp;lt;= k; i++) {    
6.	     C[i] = 0;    
7.	 }    
8.	 for (i = 0; i &amp;lt; n; i++) {    
9.	     C[A[i]]++;    
10.	 }    
11.	 for (i = 1; i &amp;lt;= k; i++) {    
12.	     C[i] = C[i] + C[i - 1];    
13.	 }    
14.	 for (i = n - 1; i &amp;gt;= 0; i--) {    
15.	     B[C[A[i]] - 1] = A[i];    
16.	     C[A[i]]--;    
17.	 }  

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;桶排序：&lt;/strong&gt;&lt;br&gt;
步骤1：人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；&lt;br&gt;
步骤2：遍历输入数据，并且把数据一个一个放到对应的桶里去；&lt;br&gt;
步骤3：对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；&lt;br&gt;
步骤4：从不是空的桶里把排好序的数据拼接起来。&lt;br&gt;
注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1649608296765.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void bucketSort(int *arr, int size, int max)  
2.	{  
3.	    int i,j;  
4.	    int buckets[max];  
5.	    memset(buckets, 0, max * sizeof(int));  
6.	    for (i = 0; i &amp;lt; size; i++) {  
7.	        buckets[arr[i]]++;   
8.	    }  
9.	    for (i = 0, j = 0; i &amp;lt; max; i++) {  
10.	        while((buckets[i]--) &amp;gt;0)  
11.	            arr[j++] = i;  
12.	    }  
13.	}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;基数排序：&lt;/strong&gt;&lt;br&gt;
步骤1：取得数组中的最大数，并取得位数；&lt;br&gt;
步骤2：arr为原始数组，从最低位开始取每个位组成radix数组；&lt;br&gt;
步骤3：对radix进行计数排序（利用计数排序适用于小范围数的特点）；&lt;br&gt;
&lt;img src=&#34;https://easyzoom.github.io/post-images/1649608351602.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int get_index(int num, int dec, int order)  
2.	{  
3.	    int i, j, n;  
4.	    int index;  
5.	    int div;  
6.	    for (i = dec; i &amp;gt; order; i--) {  
7.	        n = 1;  
8.	        for (j = 0; j &amp;lt; dec - 1; j++)  
9.	            n *= 10;  
10.	        div = num / n;  
11.	        num -= div * n;  
12.	        dec--;  
13.	    }  
14.	    n = 1;  
15.	    for (i = 0; i &amp;lt; order - 1; i++)  
16.	        n *= 10;  
17.	    index = num / n;  
18.	    return index;  
19.	}  
20.	   
21.	void RadixSort(int *arr, int len, int dec, int order)  
22.	{  
23.	    int i, j;  
24.	    int index;   
25.	    int tmp[len];   
26.	    int num[10];  
27.	    memset(num, 0, 10 * sizeof(int));   
28.	    memset(tmp, 0, len * sizeof(int));  
29.	   
30.	    if (dec &amp;lt; order) {  
31.	        return;  
32.	    }  
33.	    for (i = 0; i &amp;lt; len; i++) {  
34.	        index = get_index(arr[i], dec, order);  
35.	        num[index]++;   
36.	    }  
37.	   
38.	    for (i = 1; i &amp;lt; 10; i++) {  
39.	        num[i] += num[i-1];  
40.	    }  
41.	    for (i = len - 1; i &amp;gt;= 0; i--) {  
42.	        index = get_index(arr[i], dec, order);   
43.	        j = --num[index];   
44.	        tmp[j] = arr[i];   
45.	    }  
46.	   
47.	    for (i = 0; i &amp;lt; len; i++) {  
48.	        arr[i] = tmp[i];   
49.	    }  
50.	    RadixSort(arr, len, dec, order+1);  
51.	}  
&lt;/code&gt;&lt;/pre&gt;
">排序算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/c-yu-yan/"" data-c="
          &lt;p&gt;&lt;strong&gt;1) C 和 C++ 区别&lt;/strong&gt;&lt;br&gt;
（1）C语言特点：&lt;br&gt;
a.作为一种面向过程的结构化语言，易于调试和维护；&lt;br&gt;
b.表现能力和处理能力极强，可以直接访问内存的物理地址；&lt;br&gt;
c.C语言实现了对硬件的编程操作，也适合于应用软件的开发；&lt;br&gt;
d.C语言还具有效率高，可移植性强等特点。&lt;br&gt;
（2）C++语言特点：&lt;br&gt;
a在C语言的基础上进行扩充和完善，使C++兼容了C语言的面向过程特点，又成为了一种面向对象的程序设计语言；&lt;br&gt;
b.可以使用抽象数据类型进行基于对象的编程；&lt;br&gt;
c.可以使用多继承、多态进行面向对象的编程；&lt;br&gt;
d.可以担负起以模版为特征的泛型化编程。&lt;br&gt;
C++与C语言的本质差别：在于C++是面向对象的，而C语言是面向过程的。或者说C++是在C语言的基础上增加了面向对象程序设计的新内容，是对C语言的一次更重要的改革，使得C++成为软件开发的重要工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.const有什么用途&lt;/strong&gt;&lt;br&gt;
主要有三点：&lt;br&gt;
1：定义只读变量，即常量&lt;br&gt;
2：修饰函数的参数和函数的返回值&lt;br&gt;
3：修饰函数的定义体，这里的函数为类的成员函数，被const修饰的成员函数代表不修改成员变量的值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 指针和引用的区别&lt;/strong&gt;&lt;br&gt;
1：引用是变量的一个别名，内部实现是只读指针&lt;br&gt;
2：引用只能在初始化时被赋值，其他时候值不能被改变，指针的值可以在任何时候被改变&lt;br&gt;
3：引用不能为NULL，指针可以为NULL&lt;br&gt;
4：引用变量内存单元保存的是被引用变量的地址&lt;br&gt;
5：“sizeof 引用&amp;quot; = 指向变量的大小 ， &amp;quot;sizeof 指针&amp;quot;= 指针本身的大小&lt;br&gt;
6：引用可以取地址操作，返回的是被引用变量本身所在的内存单元地址&lt;br&gt;
7：引用使用在源代码级相当于普通的变量一样使用，做函数参数时，内部传递的实际是变量地址&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. C++中有了malloc / free , 为什么还需要 new / delete&lt;/strong&gt;&lt;br&gt;
1,malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。&lt;br&gt;
2,对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。&lt;br&gt;
对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。&lt;br&gt;
由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。&lt;br&gt;
3,因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 编写类String 的构造函数，析构函数，拷贝构造函数和赋值函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 多态的实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. 单链表的逆置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8. 堆和栈的区别&lt;/strong&gt;&lt;br&gt;
栈区stack:由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间&lt;br&gt;
堆区heap:需要程序员自己申请，并指明大小，在c中malloc函数&lt;br&gt;
如p1 = (char *)malloc(10);&lt;br&gt;
动态数据区一般就是“堆栈”。“栈(stack)”和“堆(heap)”是两种不同的动态数据区，栈是一种线性结构，堆是一种链式结构。进程的每个线程都有私有的“栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。一个堆栈可以通过“基地址”和“栈顶”地址来描述。全局变量和静态变量分配在静态数据区，本地变量分配在动态数据区，即堆栈中。程序通过堆栈的基地址和偏移量来访问本地变量。&lt;br&gt;
队列是先进先出，有出口和入口，先进去可以先出来。&lt;br&gt;
栈就像一个箱子，后放上去的，可以先出来&lt;br&gt;
堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。{堆是指程序运行是申请的动态内存，而栈只是指一种使用堆的方法(即先进后出)。&lt;br&gt;
栈是先进后出的，但是于堆而言却没有这个特性，两者都是存放临时数据的地方。对于堆，我们可以随心所欲的进行增加变量和删除变量，不要遵循什么次序，只要你喜欢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10. 不调用C/C++ 的字符串库函数，编写strcpy&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char * strcpy(char * strDest,const char * strSrc)
 {
     if ((strDest==NULL)||strSrc==NULL))
            return NULL;    
      char * strDestCopy=strDest; 
      while ((*strDest++=*strSrc++)!=&#39;\0&#39;); 
       *strDest = &#39;\0&#39;;
        return strDestCopy;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;11. 关键字static的作用&lt;/strong&gt;&lt;br&gt;
1.函数体内 static 变量的作用范围为该函数体，不同于 auto 变量， 该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值&lt;br&gt;
2.在模块内的 static 全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问&lt;br&gt;
3.在模块内的static 函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内&lt;br&gt;
4.在类的static 成员变量属于整个类所拥有，对类的所以对象只有一份拷贝&lt;br&gt;
5.在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的 static 成员变量&lt;br&gt;
介绍它最重要的一条：隐藏。（static函数，static变量均可） --&amp;gt; 对应上面的2、3项&lt;br&gt;
当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。&lt;br&gt;
举例来说明。同时编译两个源文件，一个是a.c，另一个是main.c。&lt;br&gt;
1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。&lt;br&gt;
2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。&lt;br&gt;
3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;12.sizeof和strlen区别？&lt;/strong&gt;&lt;br&gt;
sizeof是运算符，在头文件中typedef为unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。&lt;br&gt;
它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。具体而言，当参数分别如下时，sizeof返回的值表示的含义如下：数组——编译时分配的数组空间大小；指针——存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为4）。&lt;br&gt;
strlen是函数，要在运行时才能计算。参数必须是字符型指针。当数组名作为参数传入时，实际上数组就退化成指针了。&lt;br&gt;
它的功能是：返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。返回的长度大小不包括NULL。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;13.C语言的四种拷贝函数&lt;/strong&gt;&lt;br&gt;
strcpy()函数用来复制字符串，其原型为：char*strcpy(char *dest,const char *src);&lt;br&gt;
【参数】dest 为目标字符串指针，src为源字符串指针。&lt;br&gt;
注意：src 和 dest 所指的内存区域不能重叠，且 dest必须有足够的空间放置 src 所包含的字符串（包含结束符NULL）。&lt;br&gt;
【返回值】成功执行后返回目标数组指针dest。&lt;br&gt;
注意：如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(bufferOverflow)的错误情况，在编写程序时需要特别留意，或者用strncpy()来取代。&lt;/p&gt;
&lt;p&gt;memcpy()用来复制内存，其原型为：void *memcpy ( void * dest, const void * src, size_t num );&lt;br&gt;
memcpy()会复制src所指的内存内容的前num个字节到dest所指的内存地址上。&lt;br&gt;
memcpy()并不关心被复制的数据类型，只是逐字节地进行复制，这给函数的使用带来了很大的灵活性，可以面向任何数据类型进行复制。&lt;br&gt;
注意：dest 指针要分配足够的空间，也即大于等于 num字节的空间。如果没有分配空间，会出现断错误。&lt;br&gt;
dest和src所指的内存空间不能重叠（如果发生了重叠，使用 memmove() 会更加安全）。与 strcpy() 不同的是，memcpy() 会完整的复制 num个字节，不会因为遇到“\0”而结束。&lt;br&gt;
【返回值】返回指向 dest 的指针。注意返回的指针类型是void，使用时一般要进行强制类型转换。&lt;br&gt;
处理内存重叠时的情况：先将内容复制到类似缓冲区的地方，再用缓冲区中的内容覆盖 dest指向的内存&lt;/p&gt;
&lt;p&gt;memmove()用来复制内存内容，其原型为：void *memmove(void *dest, const void *src, size_t num);&lt;br&gt;
说明：memmove()与memcpy()类似都是用来复制src所指的内存内容前num个字节到dest所指的地址上。不同的是，memmove()更为灵活，当src和dest所指的内存区域重叠时，memmove()仍然可以正确的处理，不过执行效率上会比使用memcpy()略慢些。&lt;/p&gt;
&lt;p&gt;strncpy()用来复制字符串的前n个字符，其原型为：char *strncpy(char *dest, const char *src, size_t n);&lt;br&gt;
【参数说明】dest 为目标字符串指针，src 为源字符串指针。&lt;br&gt;
【返回值】返回字符串dest。&lt;br&gt;
strncpy()会将字符串src前n个字符拷贝到字符串dest。&lt;br&gt;
不像strcpy()，strncpy()不会向dest追加结束标记&#39;\0&#39;，这就引发了很多不合常理的问题，将在下面的示例中说明。&lt;br&gt;
注意：src和dest所指的内存区域不能重叠，且dest必须有足够的空间放置n个字符。使用strncpy()最安全方式是使n等于strlen(src)+1，即拷贝整个字符串，同时将&#39;\0&#39;追加到dest。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;14.用变量a给出下面的定义&lt;/strong&gt;&lt;br&gt;
a) 一个整型数（An integer）&lt;br&gt;
b) 一个指向整型数的指针（A pointer to an integer）&lt;br&gt;
c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）&lt;br&gt;
d) 一个有10个整型数的数组（An array of 10 integers）&lt;br&gt;
e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）&lt;br&gt;
f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）&lt;br&gt;
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）&lt;br&gt;
h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integerargument and return an integer ）&lt;br&gt;
答案是：&lt;br&gt;
a) int a; // An integer&lt;br&gt;
b) int *a; // A pointer to an integer&lt;br&gt;
c) int **a; // A pointer to a pointer to an integer&lt;br&gt;
d) int a[10]; // An array of 10 integers&lt;br&gt;
e) int *a[10]; // An array of 10 pointers to integers&lt;br&gt;
f) int (*a)[10]; // A pointer to an array of 10 integers&lt;br&gt;
g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer&lt;br&gt;
h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;15.结构与联合有和区别？&lt;/strong&gt;&lt;br&gt;
答：(1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。&lt;br&gt;
(2). 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;16.进程与线程的区别&lt;/strong&gt;&lt;br&gt;
进程是拥有资源的基本单位，线程是调度和分配的基本单位&lt;br&gt;
线程和进程都可以并发执行&lt;br&gt;
中断与异常的区别&lt;br&gt;
中断是外部硬件产生的电信号通过处理器的中断端口打断处理器的处理过程&lt;br&gt;
异常是处理器内部执行到错误指令、或者在执行期间出现错误，必须靠内核处理的时候就会产生一个异常&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;17.三种内存分配&lt;/strong&gt;&lt;br&gt;
1、从静态数据区分配：在程序编译的时候就已经分配好了，程序运行区间都存在&lt;br&gt;
2、从栈上分配：在执行函数的时候，函数内部的局部变量可以在栈上申请空间，并随函数的结束而释放&lt;br&gt;
3、从堆上分配：手动分配空间使用new和malloc，释放时使用deleted和free&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;18.为什么不能在中断中使用printf&lt;/strong&gt;&lt;br&gt;
printf不能在中断中被调用的原因是它是一个不可重入函数&lt;/p&gt;
&lt;p&gt;printf不能在中断中被调用的原因是它是一个不可重入函数，而在中断中要避免调用不可重入函数，首先我们先说说什么是可重入函数，什么是不可重入函数&lt;br&gt;
简单说来，区分一个函数是否可重入就是看这个函数能否在未返回的时候再次被调用。而造成一个函数不可重入的原因往往是使用了全局变量，如果一个函数未返回再执行一次会导致对全局变量的操作是不安全的。就例如我们常用的printf、malloc、free都是不可重入的函数，printf会引用全局变量stdout，malloc，free会引用全局的内存分配表，在多线程的环境下，如果没有很好的处理数据保护和互斥访问，就会发生错误&lt;br&gt;
在unix里面通常都有加上_r后缀的同名可重入函数版本&lt;br&gt;
如果实在没有，不妨在可预见的发生错误的地方尝试加上保护锁同步机制等等&lt;br&gt;
printf，malloc，free等都是不可重入函数&lt;br&gt;
在多线程的环境下，如果没有很好的处理数据保护和互斥访问，就会发生错误&lt;br&gt;
在unix里面通常都有加上_r后缀的同名可重入函数版本&lt;br&gt;
如果实在没有，不妨在可预见的发生错误的地方尝试加上保护锁同步机制等等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;19.什么是不可重入函数？&lt;/strong&gt;&lt;br&gt;
可重入函数主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入 OS 调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。&lt;/p&gt;
&lt;p&gt;满足下列条件的函数多数是不可重入的：&lt;br&gt;
函数体内使用了静态（static）的数据结构；&lt;br&gt;
函数体内调用了 malloc() 或者 free() 函数；&lt;br&gt;
函数体内调用了标准 I/O 函数;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;20.如何写可重入的函数&lt;/strong&gt;&lt;br&gt;
我们只要遵循几条规则，写出来的函数就是可重入的：&lt;/p&gt;
&lt;p&gt;不要使用全局变量。因为别的代码很可能覆盖这些变量值&lt;br&gt;
在和硬件发生交互的时候，切记执行类似disinterrupt()之类的操作，就是关闭硬件中断。完成交互记得打开中断，在有些系列上，这叫做“进入/退出核心”或者用OS_ENTER_KERNAL/OS_EXIT_KERNAL来描述&lt;br&gt;
不能调用任何不可重入的函数&lt;br&gt;
谨慎使用堆栈。最好先在使用前先OS_ENTER_KERNAL&lt;br&gt;
总而言之我们就是要保证中断是安全的！&lt;/p&gt;
&lt;p&gt;1.在函数体内不访问那些全局变量；&lt;br&gt;
2.如果必须访问全局变量，记住利用互斥信号量来保护全局变量。或者调用该函数前关中断，调用后再开中断；&lt;br&gt;
3.不使用静态局部变量；&lt;br&gt;
4.坚持只使用缺省态（auto）局部变量；&lt;br&gt;
5.在和硬件发生交互的时候，切记关闭硬件中断。完成交互记得打开中断，在有些系列上，这叫做“进入/退出核心”或者用 OS_ENTER_KERNAL/OS_EXIT_KERNAL 来描述；&lt;br&gt;
6.不能调用任何不可重入的函数；&lt;br&gt;
7.谨慎使用堆栈。最好先在使用前先 OS_ENTER_KERNAL；这是临界区保护&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;21. &lt;strong&gt;attribute&lt;/strong&gt;((packed))详解&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;attribute&lt;/strong&gt; ((packed)) 的作用就是告诉编译器取消结构在编译过程中的优化对齐,按照实际占用字节数进行对齐，是GCC特有的语法。这个功能是跟操作系统没关系，跟编译器有关，gcc编译器不是紧凑模式的，我在windows下，用vc的编译器也不是紧凑的，用tc的编译器就是紧凑的。例如：&lt;br&gt;
在TC下：struct my{ char ch; int a;} sizeof(int)=2;sizeof(my)=3;（紧凑模式）&lt;br&gt;
在GCC下：struct my{ char ch; int a;} sizeof(int)=4;sizeof(my)=8;（非紧凑模式）&lt;br&gt;
在GCC下：struct my{ char ch; int a;}&lt;strong&gt;attrubte&lt;/strong&gt; ((packed)) sizeof(int)=4;sizeof(my)=5&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;22.static __INLINE 内联函数&lt;/strong&gt;&lt;br&gt;
_inline函数也称为内联函数或内嵌函数，_inline定义的类的内联函数，函数代码被放入符号调用表，使用时直接展开，不需要调用，即在编译期间将所调用的函数的代码直接嵌入到主调函数中，是一种以空间换时间的函数。&lt;br&gt;
根据上面的定义可以知道，如果static inline关键字生效（因为只有编译器有最终决定权，我们只有建议权，这点在后面会细讲），static inline会以一种类似于宏定义的方式，将调用被static inline修饰的函数的语句替换为那个函数体对应的指令，但实际上只是inline的作用，static作用其实是维护代码的健壮性，实验中会加以证明。 所以：&lt;/p&gt;
&lt;p&gt;好处：&lt;br&gt;
减少调用函数时的开销，如：&lt;br&gt;
减少传参时可能引起的压栈出栈的开销。&lt;br&gt;
减少PC跳转时对流水线的破坏。&lt;br&gt;
坏处： * 代码所占体积会更大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;23.#if defined和#if !defined(c语言的宏定义)&lt;/strong&gt;&lt;br&gt;
因为对于一个大程序而言,我们可能要定义很多常量( 不管是放在源文件还是头文件 ),那么我们有时考虑定义某个常量时,我们就必须返回检查原来此常量是否定义,但这样做很麻烦.if defined宏正是为这种情况提供了解决方案.举个例子,如下:&lt;br&gt;
#define ....&lt;br&gt;
#define ....&lt;br&gt;
....&lt;br&gt;
....&lt;br&gt;
#define a 100&lt;br&gt;
....&lt;br&gt;
此时，我们要检查a是否定义（假设我们已经记不着这点了）,或者我们要给a一个不同的值，就加入如下句子&lt;br&gt;
#if defined a&lt;br&gt;
#undef a&lt;br&gt;
#define a 200&lt;br&gt;
#endif&lt;br&gt;
上述语句检验a是否被定义，如果被定义，则用#undef语句解除定义，并重新定义a为200&lt;br&gt;
同样，检验a是否定义：&lt;br&gt;
#ifndef a    //如果a没有被定义&lt;br&gt;
#define a 100&lt;br&gt;
#endif&lt;/p&gt;
&lt;p&gt;以上所用的宏中：#undef为解除定义，#ifndef是if not defined的缩写，即如果没有定义。&lt;br&gt;
这就是#if defined 的唯一作用！&lt;br&gt;
#define a 100&lt;br&gt;
#endif&lt;br&gt;
以上所用的宏中：#undef为解除定义，#ifndef是if not defined的缩写，即如果没有定义。&lt;br&gt;
这就是#if defined 的唯一作用！&lt;br&gt;
1）&lt;br&gt;
#if defined XXX_XXX&lt;br&gt;
#endif&lt;br&gt;
是条件编译，是根据你是否定义了XXX_XXX这个宏，而使用不同的代码。&lt;br&gt;
一般.h文件里最外层的&lt;br&gt;
#if !defined XXX_XXX&lt;br&gt;
#define XXX_XXX&lt;br&gt;
#endif&lt;br&gt;
是为了防止这个.h头文件被重复include。&lt;br&gt;
2）&lt;br&gt;
#error XXXX&lt;br&gt;
是用来产生编译时错误信息XXXX的，一般用在预处理过程中；&lt;br&gt;
例子：&lt;br&gt;
#if !defined(__cplusplus)&lt;br&gt;
#error C++ compiler required.&lt;br&gt;
#endif&lt;/p&gt;
">C语言</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/51-dan-pian-ji/"" data-c="
          ">51单片机</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/gong-xiang-nei-cun-shi-xian/"" data-c="
          &lt;p&gt;在异构处理器中除了传统的rpmag通信之外，我们可以通过自己实现共享内存的方式实现高效的数据交换&lt;br&gt;
这里的共享内存交换属于无锁的情况下实现的，由于异构处理器中所使用的操作系统不一致，加锁反而是个麻烦的事情，所以这里咱们使用无锁结构的方法去实现共享内存&lt;/p&gt;
">共享内存实现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/cmake/"" data-c="
          &lt;p&gt;w&lt;/p&gt;
">CMAKE</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/menuconfig/"" data-c="
          &lt;p&gt;安装MinGW&lt;br&gt;
运行mingw-get-setup.exe后仅选mingw32-base和mingw32-gcc-g++。添加环境变量C:\MinGW\bin&lt;br&gt;
安装GnuWin32&lt;br&gt;
2.1 运行GetGnuWin32-0.6.3.exe后，路径选xxx\GetGnuWin32。&lt;br&gt;
2.2 双击download.bat，一路回车&lt;br&gt;
2.3 双击install.bat，一路回车&lt;br&gt;
2.4 最后我将GetGnuWin32文件夹copy到了c盘。添加环境变量C:\GetGnuWin32\gnuwin32\bin，C:\GetGnuWin32\gnuwin32\include和C:\GetGnuWin32\gnuwin32\lib&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;&lt;strong&gt;MinGW&lt;/strong&gt;&lt;br&gt;
—- MinGW Base System&lt;br&gt;
——– MinGW Compiler Suit&lt;br&gt;
———— mingw32-binutils 必选，用于编译生成的 .o 文件的链接、汇编、生成静态库等。&lt;br&gt;
———— mingw32-gcc 必选，核心的 C 编译器。&lt;br&gt;
———— mingw32-gcc-ada 可选，Ada 编译器。&lt;br&gt;
———— mingw32-gcc-fortran 可选，Fortran 编译器。&lt;br&gt;
———— mingw32-gcc-g++ 建议，C++ 编译器。&lt;br&gt;
———— mingw32-gcc-objc 可选，Objective-C 编译器。&lt;br&gt;
———— mingw32-gcc-v3-* 不建议，第三版 GCC 编译器。&lt;br&gt;
———— mingw32-libgcc 必需，C 编译器编译出来的程序的运行库。&lt;br&gt;
———— mingw32-libgfortran 可选，如选择了 Fortran 编译器，则必选，Fortran 运行库。&lt;br&gt;
———— mingw32-libgnat 可选，如选择了 Ada 编译器，则必选，Ada 运行库。&lt;br&gt;
———— mingw32-libobjc 可选，如选择了 Objective-C 编译器，则必选，Objective-C 运行库。&lt;br&gt;
———— mingw32-libstdc++ 可选，如选择了 C++ 编译器，则必选，C++ 运行库。&lt;br&gt;
———— mingw32-libgomp 可选，GNU OpenMP 库，高精度运算。&lt;br&gt;
———— mingw32-libquadmath 可选，QuadMath 库，数学运行。&lt;br&gt;
———— mingw32-libssp 可选，StackProtect 库，栈保护。&lt;br&gt;
———— mingw32-mingwrt 必选，MinGW 工具的运行库。&lt;br&gt;
———— mingw32-w32api 必选，运行 Windows 程序所必需的 DLL 文件。&lt;br&gt;
——– MinGW Source-Level Debugger&lt;br&gt;
———— mingw32-gdb 可选，GNU Debugger，命令窗口的调试器。&lt;br&gt;
——– MinGW Standard Libraries&lt;br&gt;
———— mingw32-gmp 可选，GNU 多精度运算库。&lt;br&gt;
———— mingw32-libgmp 可选，GMP 库的 DLL 文件。&lt;br&gt;
———— mingw32-libgmpxx 可选，GMP 库用于 C++ 的 DLL 文件。&lt;br&gt;
———— mingw32-mpfr 可选，MPFR 多精度运算库。&lt;br&gt;
———— mingw32-libmpfr 可选，MPFR 多精度浮点运算库的 DLL 文件。&lt;br&gt;
———— mingw32-mpc 可选，MPC 多精度运算库。&lt;br&gt;
———— mingw32-libmpc 可选，MPC 多精度浮点运算库的 DLL 文件。&lt;br&gt;
———— mingw32-libpthread-old 可选，旧版本的 POSIX 线程库的 DLL 文件。&lt;br&gt;
———— mingw32-libpthreadgc 可选，标准的 POSIX 线程库的 DLL 文件。&lt;br&gt;
———— mingw32-libpthreadgce 可选，使用 C++ 异常处理的 POSIX 线程库的 DLL 文件。&lt;br&gt;
———— mingw32-libquserex 可选，用于内核态的 POSIX 线程库的 DLL 文件。&lt;br&gt;
———— mingw32-libz 可选，zlib 库，用于 Zip 压缩及解压。&lt;br&gt;
———— mingw32-mingwrt 必选，MinGW 的开发库。&lt;br&gt;
———— mingw32-pthreads-w32 可选，POSIX 线程库的开发文件。&lt;br&gt;
———— mingw32-w32api 必选，Win32 SDK 的开发库。&lt;br&gt;
—- MinGW Libraries&lt;br&gt;
——– MinGW Supplementary Libraries&lt;br&gt;
———— mingw32-lua 可选，Lua 语言的编译器、运行库等。&lt;br&gt;
——– MinGW Contributed Libraries&lt;br&gt;
———— mingw32-libunistring 可选，Unicode 字符串处理库。&lt;br&gt;
—- MinGW Contributed&lt;br&gt;
——– MinGW Contributed Applications&lt;br&gt;
———— mingw32-tcl 可选，Tool Command Language，tcl 语言。&lt;br&gt;
———— mingw32-tk 可选，tcl 语言的图形用户界面。&lt;br&gt;
———— mingw32-xerces-c 可选，Xerces-C++ XML 解析库。&lt;br&gt;
—- MinGW Autotools&lt;br&gt;
——– mingw32-autoconf 可选，用于 MSYS，Autoconf 的封装脚本&lt;br&gt;
——– mingw32-autoconf2.* 可选，最好全选，自动配置脚本生成工具。&lt;br&gt;
——– mingw32-automake 可选，用于 MSYS，Automake 的封装脚本&lt;br&gt;
——– mingw32-automake1.* 可选，最好全选，自动 Makefile 生成工具。&lt;br&gt;
——– mingw32-autotools 可选，用于 MSYS，自动选择 autoconf automake 等 Package。&lt;br&gt;
——– mingw32-gettext 建议，GNU 软件国际化（即多语言）库。&lt;br&gt;
——– mingw32-libasprintf 建议，GNU 软件国际化库。&lt;br&gt;
——– mingw32-libcharset 可选，字符集转换库。&lt;br&gt;
——– mingw32-libgettextpo 建议，GNU 软件国际化（即多语言）库。&lt;br&gt;
——– mingw32-libiconv 可选，字符集转换库。&lt;br&gt;
——– mingw32-libintl 建议，GNU 软件国际化库的运行时 DLL 文件。&lt;br&gt;
——– mingw32-libltdl 可选，可移植的 dlopen 替代库。&lt;br&gt;
——– mingw32-libtool 可选，共享库生成工具。&lt;br&gt;
MSYS&lt;br&gt;
—- MSYS Base System&lt;br&gt;
——– msys-base 可选，自动选择 MSYS 开发环境所需的一般的 Package。&lt;br&gt;
——– msys-bash 必选，Bash (Bourne Again SHell)，脚本解释器。&lt;br&gt;
——– msys-bzip2 建议，bzip2 工具及开发库、运行库。&lt;br&gt;
——– msys-core 必选，MSYS 核心文件。&lt;br&gt;
——– msys-coreutils 必选，MSYS 核心工具。&lt;br&gt;
——– msys-diffutils 建议，文件差别比较工具。&lt;br&gt;
——– msys-dos2unix 可选，将 DOS (即 Windows) 换行符转换为 Unix 换行符。&lt;br&gt;
——– msys-file 可选，判断文件类型的工具。&lt;br&gt;
——– msys-findutils 建议，查找文件的工具。&lt;br&gt;
——– msys-gawk 建议，字符串型 (Pattern) 扫描和处理语言的解释器。&lt;br&gt;
——– msys-grep 建议，打印匹配型 (Pattern) 的字符串的工具。&lt;br&gt;
——– msys-gzip 建议，gzip 工具及开发库、运行库。&lt;br&gt;
——– msys-less 建议，命令行的文本查看器。&lt;br&gt;
——– msys-locate 可选，基于数据库的 ‘find’ 工具。&lt;br&gt;
——– msys-m4 建议，GNU 宏处理器。&lt;br&gt;
——– msys-make 建议，GNU Make 工具。&lt;br&gt;
——– msys-patch 建议，文件打补丁工具。&lt;br&gt;
——– msys-sed 建议，GNU 流编辑器。&lt;br&gt;
——– msys-tar 建议，GNU Tar 文件打包工具。&lt;br&gt;
——– msys-termcap 建议，终端数据库。&lt;br&gt;
——– msys-texinfo 建议，显示帮助文件的工具。&lt;br&gt;
——– msys-tiny 可选，自动选择 MSYS 所需的最少 Package。&lt;br&gt;
——– msys-xz 建议，lzma 工具及开发库、运行库。&lt;br&gt;
—- MinGW Developer Toolkit&lt;br&gt;
——– mingw-developer-toolkit 建议，自动选择 MSYS 环境下用于 MinGW 开发所需的 Package。&lt;br&gt;
——– msys-autogen 建议，简化程序的生成，配合 autotool 使用。&lt;br&gt;
——– msys-bison 建议，GNU 语法分析器生成器。&lt;br&gt;
——– msys-bsdcpio 可选，BDS 版的 cpio 工具。&lt;br&gt;
——– msys-bsdtar 可选，BSD 版的 tar 工具。&lt;br&gt;
——– msys-cvs 可选，CVS 版本控制工具。&lt;br&gt;
——– msys-diffstat 可选，diff 工具生成文件的查看器。&lt;br&gt;
——– msys-flex 建议，快速词汇分析器生成器，一般和 bison 一起使用。&lt;br&gt;
——– msys-guile 建议，Scheme 解释器和库。&lt;br&gt;
——– msys-help2man 可选，生成 man 页面。&lt;br&gt;
——– msys-inetutils 可选，通用网络客户端，包括 telnet ftp 等。&lt;br&gt;
——– msys-libopenssl 建议，OpenSSL 库。&lt;br&gt;
——– msys-lndir 可选，Xorg 递归目录符号链接工具。&lt;br&gt;
——– msys-mksh 可选，MirBSD Korn Shell，脚本解释器。&lt;br&gt;
——– msys-mktemp 可选，创建临时文件或目录。&lt;br&gt;
——– msys-openssh 建议，OpenSSH，SSH 客户端。&lt;br&gt;
——– msys-openssl 建议，OpenSSL 工具。&lt;br&gt;
——– msys-perl 建议，Perl 解释器。&lt;br&gt;
——– msys-rsync 建议，文件传输程序。&lt;br&gt;
——– msys-vim 可选，控制台下的文件编辑器。&lt;br&gt;
—- MSYS System Builder&lt;br&gt;
——– 这个是用于编译用于 MSYS 系统的程序的编译器，一般不需要&lt;br&gt;
下载：https://sourceforge.net/projects/mingw/&lt;/p&gt;
&lt;p&gt;安装：https://blog.csdn.net/wxh0000mm/article/details/100666329&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/wxh0000mm/article/details/100666329?utm_medium=distribute.pc_relevant.none-task-blog-2&lt;sub&gt;default&lt;/sub&gt;baidujs_baidulandingword~default-0.essearch_pc_relevant&amp;amp;spm=1001.2101.3001.4242.1&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;GnuWin32&lt;/p&gt;
&lt;p&gt;下载：https://sourceforge.net/projects/getgnuwin32/&lt;/p&gt;
&lt;p&gt;安装：https://www.cnblogs.com/cnsevennight/p/4253167.html&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/qq_33160790/article/details/54884424?locationNum=5&amp;amp;fps=1&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/stm32_newlearner/article/details/84206416&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/00ce218ab598&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/ab076999fd36&lt;/p&gt;
&lt;p&gt;https://wiki.stmicroelectronics.cn/stm32mpu/wiki/Menuconfig_or_how_to_configure_kernel&lt;/p&gt;
">menuconfig</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/msys2/"" data-c="
          &lt;p&gt;pacman -Syu: 升级系统及所有已经安装的软件。&lt;br&gt;
pacman -S 软件名: 安装软件。也可以同时安装多个包，只需以空格分隔包名即可。&lt;br&gt;
pacman -Rs 软件名: 删除软件，同时删除本机上只有该软件依赖的软件。&lt;br&gt;
pacman -Ru 软件名: 删除软件，同时删除不再被任何软件所需要的依赖。&lt;br&gt;
pacman -Ssq 关键字: 在仓库中搜索含关键字的软件包，并用简洁方式显示。&lt;br&gt;
pacman -Qs 关键字: 搜索已安装的软件包。&lt;br&gt;
pacman -Qi 软件名: 查看某个软件包信息，显示软件简介,构架,依赖,大小等详细信息。&lt;br&gt;
pacman -Sg: 列出软件仓库上所有的软件包组。&lt;br&gt;
pacman -Sg 软件包组: 查看某软件包组所包含的所有软件包。&lt;br&gt;
pacman -Sc：清理未安装的包文件，包文件位于 /var/cache/pacman/pkg/ 目录。&lt;br&gt;
pacman -Scc：清理所有的缓存文件。&lt;/p&gt;
">MSYS2</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/c-yu-yan-shen-du-jie-xi/"" data-c="
          &lt;p&gt;1.C语言的编译过程与c程序的内存结构（存储映像）&lt;/p&gt;
&lt;p&gt;1)IDE与源文件开发方式的异同&lt;br&gt;
2)编译的详细过程&lt;br&gt;
3)编译器集合的组成&lt;br&gt;
4)gcc-v,编译信息的详细分析&lt;br&gt;
5)可重定位目标文件(.o)格式介绍&lt;br&gt;
6)链接器链接时，符号解析和重定位做了什么事情&lt;br&gt;
7)可执行目标文件的格式，以及可执行目标文件的加载、执行&lt;br&gt;
8)程序内存结构介绍，代码和数据(常量、变量)是如何存放在程序的内存结构中的&lt;/p&gt;
&lt;p&gt;2.预处理详细介绍&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1)宏定义
2)条件编倒
3)头文件包
&amp;lt;&amp;gt;&amp;quot;&amp;quot;、为什么 include很少包含.c文件，头文件中的 ifndef XXX #define XXX 
#endi条件编译的作用
4)一些特殊的预编译关键字
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.存储类、作用域、生命周期、链接属性&lt;/p&gt;
&lt;p&gt;1)介绍什么是存储类、作用域、生命周期、连接属性&lt;br&gt;
2)介绍 extern、 static、auto、 register等等关键字，与存储类、作用域、生命周期、连接属性之间关系&lt;br&gt;
3)介绍什么是无链接、内锥接、外链接&lt;br&gt;
4)介绍为什么函数一定要声明，函数声明的目的到底是什么，不进行函数声明行不行&lt;br&gt;
等等&lt;/p&gt;
&lt;p&gt;4.指针、函数&lt;/p&gt;
&lt;p&gt;指针&lt;/p&gt;
&lt;p&gt;1)指针概念（一级指针与多级指针）&lt;br&gt;
2)指针的强制转换到底做了什么&lt;br&gt;
3)野指针、段错误&lt;br&gt;
4) const与指针&lt;br&gt;
等&lt;/p&gt;
&lt;p&gt;函数&lt;/p&gt;
&lt;p&gt;1)函数指针与指针函数&lt;br&gt;
指针的概念本身很简单，我们常说指针难，并不是指针概念难，而是指针与函数、数组、字符串、结构体等相结合后，里而有很多不易理解的地方，如果你只是理解了指针本身的概念的话，实际上你的指针并没有学会。&lt;br&gt;
2)指针与函数传参&lt;br&gt;
3)函数调用时機的活动记录&lt;br&gt;
4)回调函数：C语言模拟面向对象的思想时，与回调函数密不可分&lt;br&gt;
5)递归函数&lt;br&gt;
6)内联函数&lt;br&gt;
7) const与函数传参&lt;br&gt;
9)结构体与函数传参、返回值&lt;/p&gt;
&lt;p&gt;5.c函数库&lt;/p&gt;
&lt;p&gt;1)c静态库与动态库&lt;br&gt;
2)如何制作自己的静态库与动态库( windows和 Linux)&lt;br&gt;
3)静态库和动态库是如何链接到我们的程序中的&lt;br&gt;
4)什么是动态库的显示加载和隐式加载&lt;/p&gt;
&lt;p&gt;6.数组与字符串&lt;/p&gt;
&lt;p&gt;1)数组的构建原理（多维数组是怎么基于一维数组引申出来的)&lt;br&gt;
2)数组指针与指针数组&lt;br&gt;
3)如何使用多级指针构建多维数组，并与传统的多维数组进行对比&lt;br&gt;
4)数组与 sizeof和 strlen&lt;br&gt;
5)字符串与数组&lt;br&gt;
6)字符串指针&lt;br&gt;
char*p=&amp;quot;hello&amp;quot;,对比 char buf[]=&amp;quot;hello&amp;quot;,以此回顾第1章介绍的常量这个东西。&lt;br&gt;
字符串与 sizeof和 strlen&lt;br&gt;
7)字符串指针数组与main函数的argv参数&lt;br&gt;
字符串指针数组与NUL结尾。&lt;/p&gt;
&lt;p&gt;7.结构体、联合体、枚举&lt;/p&gt;
&lt;p&gt;1)结构体的传参&lt;br&gt;
2)结构体的强制转换&lt;br&gt;
3)结构体的对齐&lt;br&gt;
4)结构体与回调函数相结合，模拟面向对象的思想&lt;br&gt;
举实例介绍面c这种模拟而向对象思想，在构建复杂c工程项目时的好处。&lt;br&gt;
5)共用体与实际应用&lt;br&gt;
6)枚举与实际应用&lt;/p&gt;
&lt;p&gt;8.c语言中无法独立成章的知识&lt;/p&gt;
&lt;p&gt;1)数据的溢出&lt;br&gt;
2)大小端序&lt;br&gt;
3)逗号表达式&lt;br&gt;
4)void的作用是什么&lt;br&gt;
5)NULL、\0、null、0的异同&lt;br&gt;
6)转义字符&lt;br&gt;
7) typedef与***_t类型&lt;br&gt;
typedef与宏、与数组、与结构体、与 const等&lt;/p&gt;
&lt;p&gt;9.c语言的位操作&lt;/p&gt;
&lt;p&gt;&amp;amp;、|、~、^等&lt;/p&gt;
&lt;p&gt;10.使用c来进行应用开发时，所涉及的一些其他相关知识&lt;/p&gt;
&lt;p&gt;1)多线程&lt;br&gt;
2)网络&lt;br&gt;
3)数据库&lt;br&gt;
4)数据结构&lt;br&gt;
单链接、双链表、内核链表&lt;/p&gt;
">c语言深度解析</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/hong-ding-yi-de-chang-yong/"" data-c="
          &lt;p&gt;防止一个头文件被重复包含&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef COMDEF_H
#define COMDEF_H
//头文件内容
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重新定义一些类型，防止由于各种平台和编译器的不同，而产生的类型字节数差异，方便移植。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c_cpp&#34;&gt;typedef unsigned char boolean; /* Boolean value type. */
typedef unsigned long int uint32; /* Unsigned 32 bit value */
typedef unsigned short uint16; /* Unsigned 16 bit value */
typedef unsigned char uint8; /* Unsigned 8 bit value */
typedef signed long int int32; /* Signed 32 bit value */
typedef signed short int16; /* Signed 16 bit value */
typedef signed char int8; /* Signed 8 bit value */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不建议使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef unsigned char byte; /* Unsigned 8 bit value type. */
typedef unsigned short word; /* Unsinged 16 bit value type. */
typedef unsigned long dword; /* Unsigned 32 bit value type. */
typedef unsigned char uint1; /* Unsigned 8 bit value type. */
typedef unsigned short uint2; /* Unsigned 16 bit value type. */
typedef unsigned long uint4; /* Unsigned 32 bit value type. */
typedef signed char int1; /* Signed 8 bit value type. */
typedef signed short int2; /* Signed 16 bit value type. */
typedef long int int4; /* Signed 32 bit value type. */
typedef signed long sint31; /* Signed 32 bit value */
typedef signed short sint15; /* Signed 16 bit value */
typedef signed char sint7; /* Signed 8 bit value */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到指定地址上的一个字节或字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define MEM_B( x ) ( *( (byte *) (x) ) )
#define MEM_W( x ) ( *( (word *) (x) ) )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;求最大值和最小值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define MAX( x, y ) ( ((x) &amp;gt; (y)) ? (x) : (y) )
#define MIN( x, y ) ( ((x) &amp;lt; (y)) ? (x) : (y) )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到一个field在结构体(struct)中的偏移量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define FPOS( type, field ) \
/*lint -e545 */ ( (dword) &amp;amp;(( type *) 0)-&amp;gt; field ) /*lint +e545 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到一个结构体中field所占用的字节数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define FSIZ( type, field ) sizeof( ((type *) 0)-&amp;gt;field )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照LSB格式把两个字节转化为一个Word&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define FLIPW( ray ) ( (((word) (ray)[0]) * 256) + (ray)[1] )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照LSB格式把一个Word转化为两个字节&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define FLOPW( ray, val ) \
(ray)[0] = ((val) / 256); \
(ray)[1] = ((val) &amp;amp; 0xFF)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到一个变量的地址(word宽度)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define B_PTR( var ) ( (byte *) (void *) &amp;amp;(var) )
#define W_PTR( var ) ( (word *) (void *) &amp;amp;(var) )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到一个字的高位和低位字节&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define WORD_LO(xxx) ((byte) ((word)(xxx) &amp;amp; 255))
#define WORD_HI(xxx) ((byte) ((word)(xxx) &amp;gt;&amp;gt; 8))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回一个比X大的最接近的8的倍数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define RND8( x ) ((((x) + 7) / 8 ) * 8 )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将一个字母转换为大写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define UPCASE( c ) ( ((c) &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; (c) &amp;lt;= &#39;z&#39;) ? ((c) - 0x20) : (c) )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;判断字符是不是10进制的数字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define DECCHK( c ) ((c) &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; (c) &amp;lt;= &#39;9&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;判断字符是不是16进制的数字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define HEXCHK( c ) ( ((c) &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; (c) &amp;lt;= &#39;9&#39;) ||\
2((c) &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; (c) &amp;lt;= &#39;F&#39;) ||\
3((c) &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; (c) &amp;lt;= &#39;f&#39;) )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;防止溢出的一个方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define INC_SAT( val ) (val = ((val)+1 &amp;gt; (val)) ? (val)+1 : (val))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回数组元素的个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define ARR_SIZE( a ) ( sizeof( (a) ) / sizeof( (a[0]) ) )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回一个无符号数n尾的值MOD_BY_POWER_OF_TWO(X,n)=X%(2^n)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define MOD_BY_POWER_OF_TWO( val, mod_by ) \
( (dword)(val) &amp;amp; (dword)((mod_by)-1) )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于IO空间映射在存储空间的结构，输入输出处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define inp(port) (*((volatile byte *) (port)))
#define inpw(port) (*((volatile word *) (port)))
#define inpdw(port) (*((volatile dword *)(port)))
#define outp(port, val) (*((volatile byte *) (port)) = ((byte) (val)))
#define outpw(port, val) (*((volatile word *) (port)) = ((word) (val)))
#define outpdw(port, val) (*((volatile dword *) (port)) = ((dword) (val)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用一些宏跟踪调试&lt;/p&gt;
&lt;p&gt;A N S I标准说明了五个预定义的宏名，其分别是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_ L I N E _
_ F I L E _
_ D A T E _
_ T I M E _
_ S T D C _
如果编译不是标准的，则可能仅支持以上宏名中的几个，或根本不支持。
记住编译程序也许还提供其它预定义的宏名。
_ L I N E _及_ F I L E _宏指令在有关# l i n e的部分中已讨论，这里讨论其余的宏名。
_ D AT E _宏指令含有形式为月/日/年的串，表示源文件被翻译到代码时的日期。
源代码翻译到目标代码的时间作为串包含在_ T I M E _中。串形式为时：分：秒。
如果实现是标准的，则宏_ S T D C _含有十进制常量1。如果它含有任何其它数，则实现是非标准的。
可以定义宏，例如：当定义了_DEBUG，输出数据信息和所在文件所在行。
#ifdef _DEBUG
#define DEBUGMSG(msg,date) printf(msg);printf(“%d%d%d”,date,_LINE_,_FILE_)
#else
#define DEBUGMSG(msg,date)
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;宏定义防止使用时错误用小括号包含。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define ADD(a,b) (a+b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用do{}while(0)语句包含多语句防止错误，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#difne DO(a,b) a+b;\
a++;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用时：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(….)
DO(a,b); //产生错误
else
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解决方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define DO(a,b) do{a+b;\
a++;}while(0)
&lt;/code&gt;&lt;/pre&gt;
">宏定义的常用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/tong-guo-buildrootqemu-da-jian-arm-linux-xu-ni-kai-fa-huan-jing/"" data-c="
          &lt;h1 id=&#34;配置工作环境&#34;&gt;配置工作环境&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;sudo apt install gcc build-essential bison flex gettext tcl sharutils libncurses-dev zlib1g-dev exuberant-ctags g++ texinfo patch vim libtool bc git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装qemu工具：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt install qemu-system-arm
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;下载buildroot&#34;&gt;下载buildroot&lt;/h1&gt;
&lt;p&gt;它通过交叉编译生成嵌入式linuxos，buildroot是Linux平台上一个构建嵌入式Linux系统的框架。整个Buildroot是由Makefile脚本和Kconfig配置文件构成的。你可以和编译Linux内核一样，通过buildroot配置，menuconfig修改，编译出一个完整的可以直接烧写到机器上运行的Linux系统软件(包含boot、kernel、rootfs以及rootfs中的各种库和应用程序)。&lt;/p&gt;
&lt;p&gt;1.首先如何使用buildroot&lt;/p&gt;
&lt;p&gt;2.选择一个defconfig；&lt;/p&gt;
&lt;p&gt;3.根据需要配置buildroot；&lt;/p&gt;
&lt;p&gt;4.编译buildroot；&lt;/p&gt;
&lt;p&gt;5.在qemu或者目标板上运行buildroot构建的系统。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone git://git.busybox.net/buildroot
├── arch:
├── board
├── boot
├── CHANGES
├── Config.in
├── Config.in.legacy
├── configs: 放置开发板的一些配置参数. 
├── COPYING
├── DEVELOPERS
├── dl: 存放下载的源代码及应用软件的压缩包. 
├── docs: 存放相关的参考文档. 
├── fs: 放各种文件系统的源代码. 
├── linux: 存放着Linux kernel的自动构建脚本. 
├── Makefile
├── Makefile.legacy
├── output: 是编译出来的输出文件夹. 
│   ├── build: 存放解压后的各种软件包编译完成后的现场.
│   ├── host: 存放着制作好的编译工具链，如gcc、arm-linux-gcc等工具.
│   ├── images: 存放着编译好的uboot.bin, zImage, rootfs等镜像文件，
                可烧写到板子里, 让linux系统跑起来.
│   ├── staging
│   └── target: 用来制作rootfs文件系统，里面放着Linux系统基本的目录结构，
                以及编译好的应用库和bin可执行文件. (buildroot根据用户配置
                把.ko .so .bin文件安装到对应的目录下去，根据用户的配置安装
                指定位置)
├── package：下面放着应用软件的配置文件，每个应用软件的配置文件有
              Config.in和soft_name.mk。其中soft_name.mk
              (这种其实就Makefile脚本的自动构建脚本)文件可以
              去下载应用软件的包。
├── README
├── support
├── system
└── toolchain
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
&lt;h3 id=&#34;buildroot目录结构&#34;&gt;buildroot目录结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;arch: CPU架构相关的配置脚本，如arm/mips/x86,这些CPU相关的配置，在制作工具链时，编译uboot和kernel时很关键.&lt;/li&gt;
&lt;li&gt;board: 在构建系统时，board默认的boot和Linux kernel配置文件，以及一些板级相关脚本&lt;/li&gt;
&lt;li&gt;boot: uboot配置脚本目录&lt;/li&gt;
&lt;li&gt;configs: 板级配置文件，该目录下的配置文件记录着该机器平台或者方案使用的工具链，boot， kernel，各种应用软件包的配置&lt;/li&gt;
&lt;li&gt;dl: download的简写，下载一些开源包。第一次下载后，下次就不会再去从官网下载了，而是从dl/目录下拿开源包，以节约时间，存放下载的源代码及应用软件的压缩包.&lt;/li&gt;
&lt;li&gt;docs:存放相关的参考文档.&lt;/li&gt;
&lt;li&gt;fs: 各种文件系统的自动构建脚本&lt;/li&gt;
&lt;li&gt;fs/skeleton放生成文件系统镜像的地方，及板子里面的系统&lt;/li&gt;
&lt;li&gt;linux: 存放Linux kernel的自动构建脚本&lt;/li&gt;
&lt;li&gt;package: 里面有丰富的应用软件的配置文件，可以通过make menuconfig，出现图形化界面进行选择丰富的开源软件包的编译和构建。第三方开源包的自动编译构建脚本，用来配置编译dl目录下载的开源包&lt;/li&gt;
&lt;li&gt;support:&lt;/li&gt;
&lt;li&gt;system: 存放文件系统目录的和设备节点的模板，这些模板会被拷贝到output/目录下，用于制作根文件系统rootfs&lt;/li&gt;
&lt;li&gt;toolchain/ 目录中存放着各种制作工具链的脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译出的output输出目录介绍&#34;&gt;编译出的output输出目录介绍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;images/存储所有映像（内核映像，引导加载程序和根文件系统映像）的位置。这些是您需要放在目标系统上的文件。目录下就是最终生成的可烧写到板子上的各种image。&lt;/li&gt;
&lt;li&gt;build/构建所有组件的位置（包括主机上Buildroot所需的工具和针对目标编译的软件包）。该目录为每个组件包含一个子目录。&lt;/li&gt;
&lt;li&gt;host/包含为主机构建的工具和目标工具链。目录放着制作好的编译工具链&lt;/li&gt;
&lt;li&gt;staging/是到内部目标工具链host/的符号链接&lt;/li&gt;
&lt;li&gt;target/目录是用来制作rootfs的，里面放着Linux系统基本的目录结构，以及各种编译好的应用库和bin可执行文件。它几乎包含了目标的完整根文件系统。除了设备文件/dev/（Buildroot无法创建它们，因为Buildroot不能以root身份运行并且不想以root身份运行）之外，所需的一切都存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;工具链&#34;&gt;工具链&lt;/h3&gt;
&lt;p&gt;Buildroot为交叉编译工具链提供了两种解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部工具链，称为Buildroot toolchain在配置接口。&lt;/li&gt;
&lt;li&gt;外部工具链External toolchain。&lt;br&gt;
我们这里选择的是外部工具链,工具链的来源可以选择下载也可以选择指定工具链前缀如：/opt/ali/ali-linux/Codescape.GNU.Tools.Package.2017.10-05.for.MIPS.MTI.Linux.CentOS-5.x86_64/usr/bin/mips-mti-linux-gnu-，我这里选择的下载工具链源码。下载完后，同时会对用来编译工具链的原始工具链解压到(BUILD_ROOT)/host/opt/ext-toolchain/目录下，然后会对工具链源码编译安装到$(BUILD_ROOT)/host/usr/bin下，这样我们的工具链就可以使用了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;配置工作环境-2&#34;&gt;配置工作环境&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;sudo apt install gcc build-essential bison flex gettext tcl sharutils libncurses-dev zlib1g-dev exuberant-ctags g++ texinfo patch vim libtool bc git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装qemu工具：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt install qemu-system-arm
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;下载buildroot-2&#34;&gt;下载buildroot&lt;/h1&gt;
&lt;p&gt;它通过交叉编译生成嵌入式linuxos，buildroot是Linux平台上一个构建嵌入式Linux系统的框架。整个Buildroot是由Makefile脚本和Kconfig配置文件构成的。你可以和编译Linux内核一样，通过buildroot配置，menuconfig修改，编译出一个完整的可以直接烧写到机器上运行的Linux系统软件(包含boot、kernel、rootfs以及rootfs中的各种库和应用程序)。&lt;/p&gt;
&lt;p&gt;1.首先如何使用buildroot&lt;/p&gt;
&lt;p&gt;2.选择一个defconfig；&lt;/p&gt;
&lt;p&gt;3.根据需要配置buildroot；&lt;/p&gt;
&lt;p&gt;4.编译buildroot；&lt;/p&gt;
&lt;p&gt;5.在qemu或者目标板上运行buildroot构建的系统。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone git://git.busybox.net/buildroot
├── arch:
├── board
├── boot
├── CHANGES
├── Config.in
├── Config.in.legacy
├── configs: 放置开发板的一些配置参数. 
├── COPYING
├── DEVELOPERS
├── dl: 存放下载的源代码及应用软件的压缩包. 
├── docs: 存放相关的参考文档. 
├── fs: 放各种文件系统的源代码. 
├── linux: 存放着Linux kernel的自动构建脚本. 
├── Makefile
├── Makefile.legacy
├── output: 是编译出来的输出文件夹. 
│   ├── build: 存放解压后的各种软件包编译完成后的现场.
│   ├── host: 存放着制作好的编译工具链，如gcc、arm-linux-gcc等工具.
│   ├── images: 存放着编译好的uboot.bin, zImage, rootfs等镜像文件，
                可烧写到板子里, 让linux系统跑起来.
│   ├── staging
│   └── target: 用来制作rootfs文件系统，里面放着Linux系统基本的目录结构，
                以及编译好的应用库和bin可执行文件. (buildroot根据用户配置
                把.ko .so .bin文件安装到对应的目录下去，根据用户的配置安装
                指定位置)
├── package：下面放着应用软件的配置文件，每个应用软件的配置文件有
              Config.in和soft_name.mk。其中soft_name.mk
              (这种其实就Makefile脚本的自动构建脚本)文件可以
              去下载应用软件的包。
├── README
├── support
├── system
└── toolchain
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
&lt;h3 id=&#34;buildroot目录结构-2&#34;&gt;buildroot目录结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;arch: CPU架构相关的配置脚本，如arm/mips/x86,这些CPU相关的配置，在制作工具链时，编译uboot和kernel时很关键.&lt;/li&gt;
&lt;li&gt;board: 在构建系统时，board默认的boot和Linux kernel配置文件，以及一些板级相关脚本&lt;/li&gt;
&lt;li&gt;boot: uboot配置脚本目录&lt;/li&gt;
&lt;li&gt;configs: 板级配置文件，该目录下的配置文件记录着该机器平台或者方案使用的工具链，boot， kernel，各种应用软件包的配置&lt;/li&gt;
&lt;li&gt;dl: download的简写，下载一些开源包。第一次下载后，下次就不会再去从官网下载了，而是从dl/目录下拿开源包，以节约时间，存放下载的源代码及应用软件的压缩包.&lt;/li&gt;
&lt;li&gt;docs:存放相关的参考文档.&lt;/li&gt;
&lt;li&gt;fs: 各种文件系统的自动构建脚本&lt;/li&gt;
&lt;li&gt;fs/skeleton放生成文件系统镜像的地方，及板子里面的系统&lt;/li&gt;
&lt;li&gt;linux: 存放Linux kernel的自动构建脚本&lt;/li&gt;
&lt;li&gt;package: 里面有丰富的应用软件的配置文件，可以通过make menuconfig，出现图形化界面进行选择丰富的开源软件包的编译和构建。第三方开源包的自动编译构建脚本，用来配置编译dl目录下载的开源包&lt;/li&gt;
&lt;li&gt;support:&lt;/li&gt;
&lt;li&gt;system: 存放文件系统目录的和设备节点的模板，这些模板会被拷贝到output/目录下，用于制作根文件系统rootfs&lt;/li&gt;
&lt;li&gt;toolchain/ 目录中存放着各种制作工具链的脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译出的output输出目录介绍-2&#34;&gt;编译出的output输出目录介绍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;images/存储所有映像（内核映像，引导加载程序和根文件系统映像）的位置。这些是您需要放在目标系统上的文件。目录下就是最终生成的可烧写到板子上的各种image。&lt;/li&gt;
&lt;li&gt;build/构建所有组件的位置（包括主机上Buildroot所需的工具和针对目标编译的软件包）。该目录为每个组件包含一个子目录。&lt;/li&gt;
&lt;li&gt;host/包含为主机构建的工具和目标工具链。目录放着制作好的编译工具链&lt;/li&gt;
&lt;li&gt;staging/是到内部目标工具链host/的符号链接&lt;/li&gt;
&lt;li&gt;target/目录是用来制作rootfs的，里面放着Linux系统基本的目录结构，以及各种编译好的应用库和bin可执行文件。它几乎包含了目标的完整根文件系统。除了设备文件/dev/（Buildroot无法创建它们，因为Buildroot不能以root身份运行并且不想以root身份运行）之外，所需的一切都存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;工具链-2&#34;&gt;工具链&lt;/h3&gt;
&lt;p&gt;Buildroot为交叉编译工具链提供了两种解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部工具链，称为Buildroot toolchain在配置接口。&lt;/li&gt;
&lt;li&gt;外部工具链External toolchain。&lt;br&gt;
我们这里选择的是外部工具链,工具链的来源可以选择下载也可以选择指定工具链前缀如：/opt/ali/ali-linux/Codescape.GNU.Tools.Package.2017.10-05.for.MIPS.MTI.Linux.CentOS-5.x86_64/usr/bin/mips-mti-linux-gnu-，我这里选择的下载工具链源码。下载完后，同时会对用来编译工具链的原始工具链解压到(BUILD_ROOT)/host/opt/ext-toolchain/目录下，然后会对工具链源码编译安装到$(BUILD_ROOT)/host/usr/bin下，这样我们的工具链就可以使用了。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;attachment:01d6eadcdcd6023ab92b3bb16f6f0a05&#34; alt=&#34;截图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;attachment:ee9add42c7de3c9fe61072db84ce06a5&#34; alt=&#34;截图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;attachment:ce5861854109bcda723e4c0daec1091f&#34; alt=&#34;截图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;attachment:4c59501b872111d50ceb4d37e8f7aba2&#34; alt=&#34;截图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;buildroot配置&#34;&gt;buildroot配置&lt;/h3&gt;
&lt;p&gt;通过make xxx_defconfig来选择一个defconfig，这个文件在config目录下。&lt;/p&gt;
&lt;p&gt;然后通过make menuconfig进行配置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Target options  ---&amp;gt;选择目标板架构特性。
Build options  ---&amp;gt;配置编译选项。
Toolchain  ---&amp;gt; 配置交叉工具链，使用buildroot工具链还是外部提供。
System configuration  ---&amp;gt;
Kernel  ---&amp;gt;
Target packages  ---&amp;gt;
Filesystem images  ---&amp;gt;
Bootloaders  ---&amp;gt;
Host utilities  ---&amp;gt;
Legacy config options  ---&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;make命令使用&#34;&gt;make命令使用&lt;/h3&gt;
&lt;p&gt;通过make help可以看到buildroot下make的使用细节，包括对package、uclibc、busybox、linux以及文档生成等配置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cleaning:
  clean                  - delete all files created by build
  distclean              - delete all non-source files (including .config)

Build:
  all                    - make world
  toolchain              - build toolchain

Configuration:
  menuconfig             - interactive curses-based configurator--------------------------------对整个buildroot进行配置
  savedefconfig          - Save current config to BR2_DEFCONFIG (minimal config)----------------保存menuconfig的配置

Package-specific:-------------------------------------------------------------------------------对package配置
  &amp;lt;pkg&amp;gt;                  - Build and install &amp;lt;pkg&amp;gt; and all its dependencies---------------------单独编译对应APP
  &amp;lt;pkg&amp;gt;-source           - Only download the source files for &amp;lt;pkg&amp;gt;
  &amp;lt;pkg&amp;gt;-extract          - Extract &amp;lt;pkg&amp;gt; sources
  &amp;lt;pkg&amp;gt;-patch            - Apply patches to &amp;lt;pkg&amp;gt;
  &amp;lt;pkg&amp;gt;-depends          - Build &amp;lt;pkg&amp;gt;&#39;s dependencies
  &amp;lt;pkg&amp;gt;-configure        - Build &amp;lt;pkg&amp;gt; up to the configure step
  &amp;lt;pkg&amp;gt;-build            - Build &amp;lt;pkg&amp;gt; up to the build step
  &amp;lt;pkg&amp;gt;-show-depends     - List packages on which &amp;lt;pkg&amp;gt; depends
  &amp;lt;pkg&amp;gt;-show-rdepends    - List packages which have &amp;lt;pkg&amp;gt; as a dependency
  &amp;lt;pkg&amp;gt;-graph-depends    - Generate a graph of &amp;lt;pkg&amp;gt;&#39;s dependencies
  &amp;lt;pkg&amp;gt;-graph-rdepends   - Generate a graph of &amp;lt;pkg&amp;gt;&#39;s reverse dependencies
  &amp;lt;pkg&amp;gt;-dirclean         - Remove &amp;lt;pkg&amp;gt; build directory-----------清除对应APP的编译目录
  &amp;lt;pkg&amp;gt;-reconfigure      - Restart the build from the configure step
  &amp;lt;pkg&amp;gt;-rebuild          - Restart the build from the build step--单独重新编译对应APP

busybox:
  busybox-menuconfig     - Run BusyBox menuconfig

uclibc:
  uclibc-menuconfig      - Run uClibc menuconfig

linux:
  linux-menuconfig       - Run Linux kernel menuconfig-----------配置Linux并保存设置
  linux-savedefconfig    - Run Linux kernel savedefconfig
  linux-update-defconfig - Save the Linux configuration to the path specified
                             by BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE

Documentation:
  manual                 - build manual in all formats
  manual-pdf             - build manual in PDF
  graph-build            - generate graphs of the build times---对编译时间、编译依赖、文件系统大小生成图标
  graph-depends          - generate graph of the dependency tree
  graph-size             - generate stats of the filesystem size
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;buildroot框架&#34;&gt;buildroot框架&lt;/h3&gt;
&lt;p&gt;Buildroot原则上是一个自动构建框架，虽然说u-boot、linux kernel这些经典的开源软件包的构建脚本，官方社区都在帮你实现了，但是有时候你还是需要加入你自己特有的app_pkg软件包，用以构建自己的应用。&lt;/p&gt;
&lt;p&gt;Buildroot提供了函数框架和变量命令框架(下一篇文章将介绍细节)，采用它的框架编写的app_pkg.mk这种Makefile格式的自动构建脚本，将被package/pkg-generic.mk 这个核心脚本展开填充到buildroot主目录下的Makefile中去。最后make all执行Buildroot主目录下的Makefile，生成你想要的image。 package/pkg-generic.mk中通过调用同目录下的pkg-download.mk、pkg-utils.mk文件，已经帮你自动实现了下载、解压、依赖包下载编译等一系列机械化的流程。你只要需要按照格式写Makefile脚app_pkg.mk，填充下载地址，链接依赖库的名字等一些特有的构建细节即可。 总而言之，Buildroot本身提供构建流程的框架，开发者按照格式写脚本，提供必要的构建细节，配置整个系统，最后自动构建出你的系统。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;attachment:e88ba79fe964c1f24c6235dd9e2330b2&#34; alt=&#34;截图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;对buildroot的配置通过Config.in串联起来，起点在根目录Config.in中。&lt;/p&gt;
&lt;br/&gt;
&lt;h2 id=&#34;配置linux-kernel&#34;&gt;配置Linux Kernel&lt;/h2&gt;
&lt;p&gt;对Linux内核的配置包括两部分：通过make menuconfig进入Kernel对内核进行选择，通过make linux-menuconfig对内核内部进行配置。&lt;/p&gt;
&lt;h3 id=&#34;选择linux内核版本&#34;&gt;选择Linux内核版本&lt;/h3&gt;
&lt;p&gt;如下“Kernel version”选择内核的版本、“Defconfig name”选择内核config文件、“Kernel binary formant”选择内核格式、“Device tree source file names”选择DT文件，&lt;/p&gt;
&lt;p&gt;在“Linux Kernel Tools”中选择内核自带的工具，比如perf。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;attachment:4170ea8970c7644f80c848040876859c&#34; alt=&#34;截图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以选择“Custom Git repository”来指定自己的Git库，在“Custom repository version”中指定branch名称。&lt;/p&gt;
&lt;p&gt;选择“Using an in-tree defconfig file”，在“Defconfig name”中输入defconfig名称，注意不需要末尾_defconfig。&lt;/p&gt;
&lt;p&gt;选择“Use a device tree present in the kernel”，在“Device Tree Source file names”中输入dts名称，不需要.dts扩展名。&lt;/p&gt;
&lt;h3 id=&#34;kernel-binary-format&#34;&gt;Kernel binary format&lt;/h3&gt;
&lt;p&gt;可以选择vmlinux或者uImage。&lt;/p&gt;
&lt;p&gt;uImage是uboot专用的映像文件，它是在zImage之前加上一个长度为64字节的“头”，说明这个内核的版本、加载位置、生成时间、大小等信息；其0x40之后与zImage没区别。&lt;/p&gt;
&lt;p&gt;zImage是ARM Linux常用的一种压缩映像文件，uImage是U-boot专用的映像文件，它是在zImage之前加上一个长度为0x40的“头”，说明这个映像文件的类型、加载位置、生成时间、大小等信息。&lt;/p&gt;
&lt;p&gt;vmlinux编译出来的最原始的内核elf文件，未压缩。&lt;/p&gt;
&lt;p&gt;zImage是vmlinux经过objcopy gzip压缩后的文件， objcopy实现由vmlinux的elf文件拷贝成纯二进制数据文件。&lt;/p&gt;
&lt;p&gt;uImage是U-boot专用的映像文件，它是在zImage之前加上一个长度为0x40的tag。&lt;/p&gt;
&lt;p&gt;选择vmlinux和uImage的区别在于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PATH=&amp;quot;/bin...&amp;quot; BR_BINARIES_DIR=/home/.../output/images /usr/bin/make -j9 HOSTCC=&amp;quot;/usr/bin/gcc&amp;quot; HOSTCFLAGS=&amp;quot;&amp;quot; ARCH=csky INSTALL_MOD_PATH=/home/.../output/target CROSS_COMPILE=&amp;quot;/home/.../output/host/bin/csky-abiv2-linux-&amp;quot; DEPMOD=/home/.../output/host/sbin/depmod INSTALL_MOD_STRIP=1 -C /home/.../linux uImage
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是vmlinux，在结尾就是vmlinux。&lt;/p&gt;
&lt;h3 id=&#34;对kernel进行配置&#34;&gt;对Kernel进行配置&lt;/h3&gt;
&lt;p&gt;通过make linux-menuconfig可以对内核内部细节进行配置。&lt;/p&gt;
&lt;p&gt;让Linux内核带符号表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# CONFIG_COMPILE_TEST is not set
CONFIG_DEBUG_INFO=y
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;配置文件系统app&#34;&gt;配置文件系统APP&lt;/h3&gt;
&lt;p&gt;对目标板文件系统内容进行配置主要通过make menuconfig进入Target packages进行。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;attachment:6138282dacf34acfa7007b7f712e7750&#34; alt=&#34;截图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在Filesystem images中配置文件系统采用的格式，以及是否使用RAM fs。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;attachment:3a75dfd7a495906b7b88a6add1f0d50c&#34; alt=&#34;截图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br/&gt;
&lt;h1 id=&#34;配置编译buildroot&#34;&gt;配置编译buildroot&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;make qemu_arm_vexpress_defconfig--------选择虚拟qemu配置
make-------------------------------------------------下载并且编译包
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果在output/images下生成zImage、vexpress-v2p-ca9.dtb、rootfs.ext2三个文件，分别是内核、DeviceTree文件和文件系统。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;qemu-system-arm -M vexpress-a9 -smp 4 -m 1024M -kernel output/images/zImage -append &amp;quot;root=/dev/mmcblk0 console=ttyAMA0 loglevel=8&amp;quot; -dtb output/images/vexpress-v2p-ca9.dtb -sd output/images/rootfs.ext2 -nographic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但需要停止qemu的时候通过killall qemu-system-arm。&lt;/p&gt;
&lt;p&gt;然后就进入如下console，输入root：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;attachment:76172a8383e3dfe81eb0f98a8d639638&#34; alt=&#34;截图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;buildroot配置-2&#34;&gt;buildroot配置&lt;/h3&gt;
&lt;p&gt;通过make xxx_defconfig来选择一个defconfig，这个文件在config目录下。&lt;/p&gt;
&lt;p&gt;然后通过make menuconfig进行配置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Target options  ---&amp;gt;选择目标板架构特性。
Build options  ---&amp;gt;配置编译选项。
Toolchain  ---&amp;gt; 配置交叉工具链，使用buildroot工具链还是外部提供。
System configuration  ---&amp;gt;
Kernel  ---&amp;gt;
Target packages  ---&amp;gt;
Filesystem images  ---&amp;gt;
Bootloaders  ---&amp;gt;
Host utilities  ---&amp;gt;
Legacy config options  ---&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;make命令使用-2&#34;&gt;make命令使用&lt;/h3&gt;
&lt;p&gt;通过make help可以看到buildroot下make的使用细节，包括对package、uclibc、busybox、linux以及文档生成等配置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cleaning:
  clean                  - delete all files created by build
  distclean              - delete all non-source files (including .config)

Build:
  all                    - make world
  toolchain              - build toolchain

Configuration:
  menuconfig             - interactive curses-based configurator--------------------------------对整个buildroot进行配置
  savedefconfig          - Save current config to BR2_DEFCONFIG (minimal config)----------------保存menuconfig的配置

Package-specific:-------------------------------------------------------------------------------对package配置
  &amp;lt;pkg&amp;gt;                  - Build and install &amp;lt;pkg&amp;gt; and all its dependencies---------------------单独编译对应APP
  &amp;lt;pkg&amp;gt;-source           - Only download the source files for &amp;lt;pkg&amp;gt;
  &amp;lt;pkg&amp;gt;-extract          - Extract &amp;lt;pkg&amp;gt; sources
  &amp;lt;pkg&amp;gt;-patch            - Apply patches to &amp;lt;pkg&amp;gt;
  &amp;lt;pkg&amp;gt;-depends          - Build &amp;lt;pkg&amp;gt;&#39;s dependencies
  &amp;lt;pkg&amp;gt;-configure        - Build &amp;lt;pkg&amp;gt; up to the configure step
  &amp;lt;pkg&amp;gt;-build            - Build &amp;lt;pkg&amp;gt; up to the build step
  &amp;lt;pkg&amp;gt;-show-depends     - List packages on which &amp;lt;pkg&amp;gt; depends
  &amp;lt;pkg&amp;gt;-show-rdepends    - List packages which have &amp;lt;pkg&amp;gt; as a dependency
  &amp;lt;pkg&amp;gt;-graph-depends    - Generate a graph of &amp;lt;pkg&amp;gt;&#39;s dependencies
  &amp;lt;pkg&amp;gt;-graph-rdepends   - Generate a graph of &amp;lt;pkg&amp;gt;&#39;s reverse dependencies
  &amp;lt;pkg&amp;gt;-dirclean         - Remove &amp;lt;pkg&amp;gt; build directory-----------清除对应APP的编译目录
  &amp;lt;pkg&amp;gt;-reconfigure      - Restart the build from the configure step
  &amp;lt;pkg&amp;gt;-rebuild          - Restart the build from the build step--单独重新编译对应APP

busybox:
  busybox-menuconfig     - Run BusyBox menuconfig

uclibc:
  uclibc-menuconfig      - Run uClibc menuconfig

linux:
  linux-menuconfig       - Run Linux kernel menuconfig-----------配置Linux并保存设置
  linux-savedefconfig    - Run Linux kernel savedefconfig
  linux-update-defconfig - Save the Linux configuration to the path specified
                             by BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE

Documentation:
  manual                 - build manual in all formats
  manual-pdf             - build manual in PDF
  graph-build            - generate graphs of the build times---对编译时间、编译依赖、文件系统大小生成图标
  graph-depends          - generate graph of the dependency tree
  graph-size             - generate stats of the filesystem size
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;buildroot框架-2&#34;&gt;buildroot框架&lt;/h3&gt;
&lt;p&gt;Buildroot原则上是一个自动构建框架，虽然说u-boot、linux kernel这些经典的开源软件包的构建脚本，官方社区都在帮你实现了，但是有时候你还是需要加入你自己特有的app_pkg软件包，用以构建自己的应用。&lt;/p&gt;
&lt;p&gt;Buildroot提供了函数框架和变量命令框架(下一篇文章将介绍细节)，采用它的框架编写的app_pkg.mk这种Makefile格式的自动构建脚本，将被package/pkg-generic.mk 这个核心脚本展开填充到buildroot主目录下的Makefile中去。最后make all执行Buildroot主目录下的Makefile，生成你想要的image。 package/pkg-generic.mk中通过调用同目录下的pkg-download.mk、pkg-utils.mk文件，已经帮你自动实现了下载、解压、依赖包下载编译等一系列机械化的流程。你只要需要按照格式写Makefile脚app_pkg.mk，填充下载地址，链接依赖库的名字等一些特有的构建细节即可。 总而言之，Buildroot本身提供构建流程的框架，开发者按照格式写脚本，提供必要的构建细节，配置整个系统，最后自动构建出你的系统。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;attachment:e88ba79fe964c1f24c6235dd9e2330b2&#34; alt=&#34;截图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;对buildroot的配置通过Config.in串联起来，起点在根目录Config.in中。&lt;/p&gt;
&lt;br/&gt;
&lt;h2 id=&#34;配置linux-kernel-2&#34;&gt;配置Linux Kernel&lt;/h2&gt;
&lt;p&gt;对Linux内核的配置包括两部分：通过make menuconfig进入Kernel对内核进行选择，通过make linux-menuconfig对内核内部进行配置。&lt;/p&gt;
&lt;h3 id=&#34;选择linux内核版本-2&#34;&gt;选择Linux内核版本&lt;/h3&gt;
&lt;p&gt;如下“Kernel version”选择内核的版本、“Defconfig name”选择内核config文件、“Kernel binary formant”选择内核格式、“Device tree source file names”选择DT文件，&lt;/p&gt;
&lt;p&gt;在“Linux Kernel Tools”中选择内核自带的工具，比如perf。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;attachment:4170ea8970c7644f80c848040876859c&#34; alt=&#34;截图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以选择“Custom Git repository”来指定自己的Git库，在“Custom repository version”中指定branch名称。&lt;/p&gt;
&lt;p&gt;选择“Using an in-tree defconfig file”，在“Defconfig name”中输入defconfig名称，注意不需要末尾_defconfig。&lt;/p&gt;
&lt;p&gt;选择“Use a device tree present in the kernel”，在“Device Tree Source file names”中输入dts名称，不需要.dts扩展名。&lt;/p&gt;
&lt;h3 id=&#34;kernel-binary-format-2&#34;&gt;Kernel binary format&lt;/h3&gt;
&lt;p&gt;可以选择vmlinux或者uImage。&lt;/p&gt;
&lt;p&gt;uImage是uboot专用的映像文件，它是在zImage之前加上一个长度为64字节的“头”，说明这个内核的版本、加载位置、生成时间、大小等信息；其0x40之后与zImage没区别。&lt;/p&gt;
&lt;p&gt;zImage是ARM Linux常用的一种压缩映像文件，uImage是U-boot专用的映像文件，它是在zImage之前加上一个长度为0x40的“头”，说明这个映像文件的类型、加载位置、生成时间、大小等信息。&lt;/p&gt;
&lt;p&gt;vmlinux编译出来的最原始的内核elf文件，未压缩。&lt;/p&gt;
&lt;p&gt;zImage是vmlinux经过objcopy gzip压缩后的文件， objcopy实现由vmlinux的elf文件拷贝成纯二进制数据文件。&lt;/p&gt;
&lt;p&gt;uImage是U-boot专用的映像文件，它是在zImage之前加上一个长度为0x40的tag。&lt;/p&gt;
&lt;p&gt;选择vmlinux和uImage的区别在于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PATH=&amp;quot;/bin...&amp;quot; BR_BINARIES_DIR=/home/.../output/images /usr/bin/make -j9 HOSTCC=&amp;quot;/usr/bin/gcc&amp;quot; HOSTCFLAGS=&amp;quot;&amp;quot; ARCH=csky INSTALL_MOD_PATH=/home/.../output/target CROSS_COMPILE=&amp;quot;/home/.../output/host/bin/csky-abiv2-linux-&amp;quot; DEPMOD=/home/.../output/host/sbin/depmod INSTALL_MOD_STRIP=1 -C /home/.../linux uImage
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是vmlinux，在结尾就是vmlinux。&lt;/p&gt;
&lt;h3 id=&#34;对kernel进行配置-2&#34;&gt;对Kernel进行配置&lt;/h3&gt;
&lt;p&gt;通过make linux-menuconfig可以对内核内部细节进行配置。&lt;/p&gt;
&lt;p&gt;让Linux内核带符号表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# CONFIG_COMPILE_TEST is not set
CONFIG_DEBUG_INFO=y
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;配置文件系统app-2&#34;&gt;配置文件系统APP&lt;/h3&gt;
&lt;p&gt;对目标板文件系统内容进行配置主要通过make menuconfig进入Target packages进行。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;attachment:6138282dacf34acfa7007b7f712e7750&#34; alt=&#34;截图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在Filesystem images中配置文件系统采用的格式，以及是否使用RAM fs。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;attachment:3a75dfd7a495906b7b88a6add1f0d50c&#34; alt=&#34;截图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br/&gt;
&lt;h1 id=&#34;配置编译buildroot-2&#34;&gt;配置编译buildroot&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;make qemu_arm_vexpress_defconfig--------选择虚拟qemu配置
make-------------------------------------------------下载并且编译包
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果在output/images下生成zImage、vexpress-v2p-ca9.dtb、rootfs.ext2三个文件，分别是内核、DeviceTree文件和文件系统。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;qemu-system-arm -M vexpress-a9 -smp 4 -m 1024M -kernel output/images/zImage -append &amp;quot;root=/dev/mmcblk0 console=ttyAMA0 loglevel=8&amp;quot; -dtb output/images/vexpress-v2p-ca9.dtb -sd output/images/rootfs.ext2 -nographic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但需要停止qemu的时候通过killall qemu-system-arm。&lt;/p&gt;
&lt;p&gt;然后就进入如下console，输入root：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;attachment:76172a8383e3dfe81eb0f98a8d639638&#34; alt=&#34;截图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">通过buildroot+qemu搭建ARM-Linux虚拟开发环境</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/linux-xue-xi-zhi-lu/"" data-c="
          &lt;p&gt;&lt;strong&gt;1.ubuntu 解决“无法获得锁 /var/lib/dpkg/lock -open”的方法&lt;/strong&gt;&lt;br&gt;
解决办法如下：&lt;br&gt;
1.终端输入 ps -aux ，列出进程。找到含有apt-get的进程，直接sudo kill PID。&lt;br&gt;
2.强制解锁,命令&lt;br&gt;
sudo rm /var/cache/apt/archives/lock&lt;br&gt;
sudo rm /var/lib/dpkg/lock&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.cmake升级&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;下载cmake
wget https://cmake.org/files/v3.9/cmake-3.9.2.tar.gz

解压文件
tar -zxvf cmake-3.9.2.tar.gz
cd cmake-3.9.2
./configure
make
sudo make install
sudo ln -sf /usr/local/bin/*  /usr/bin/
cmake --version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.自动匹配cpu个数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make -j `grep -c &#39;^processor&#39; /proc/cpuinfo`
make -j$(nproc)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.安装chrome浏览器&lt;/strong&gt;&lt;br&gt;
1.下载Chrome&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo dpkg -i google-chrome-stable_current_amd64.deb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.若报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;报错原因：缺少依赖软件包
dpkg: error processing package google-chrome-stable (--install):
 dependency problems - leaving unconfigured
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.解决办法：修复依赖关系&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install -f
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.查看Chrome版本信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;google-chrome --version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5.安装PHP版本7.2及版本切换&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;为了安装PHP版本7.2，首先，打开Ubuntu终端并输入以下命令，
以将Ondrej PHP存储库添加到Ubuntu。
sudo add-apt-repository ppa:ondrej/php
该存储库包含迄今为止的所有发行版本的PHP。
添加Ondrej存储库后，您需要使用Internet上的系统来更新系统的存储库。
这样，您可以在系统上安装软件的最新可用版本。输入以下命令以这样做：
sudo apt-get update
现在是将PHP 7.2安装到系统上的时候了。以sudo身份输入以下命令，
因为只有授权人员才能在Ubuntu上安装/卸载和配置软件：
sudo apt-get install -y php7.2
或
sudo apt-get install -y php5.6
检查您安装的PHP的版本号
php -v
php --version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;在已安装的PHP版本之间切换&lt;/em&gt;&lt;br&gt;
如果您的系统上安装了两个或多个PHP版本，则可以将系统配置为使用其中一个作为默认PHP版本。为此，最重要的是了解Ubuntu系统上当前默认启用哪个版本。&lt;br&gt;
&lt;em&gt;检查启用了哪个版本&lt;/em&gt;&lt;br&gt;
我们将介绍两种方法来检查系统上启用了哪个PHP版本：一种是通过Apache2，另一种是通过CLI。&lt;br&gt;
(1)通过Apache2&lt;br&gt;
将当前目录更改为/etc /apache2，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /etc/apache2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在apache2目录中，运行以下命令以列出系统上所有可用的PHP模式，并知道当前启用了哪种模式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls -l mods-*/*php*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(2)通过CLI&lt;br&gt;
通过CLI检查当前启用的PHP版本也非常简单。运行以下命令，该命令用于更新Ubuntu上软件的默认替代版本，从而列出所有可用替代版本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo update-alternatives --config php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上命令的输出中，当前启用的PHP版本以*符号表示。&lt;br&gt;
&lt;em&gt;从PHP 5.6切换到PHP 7.2&lt;/em&gt;&lt;br&gt;
(1)通过Apache2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先，通过以下命令禁用当前启用的PHP版本：
sudo a2dismod php5.6
然后，通过以下命令启用其他版本的PHP：
sudo a2enmod php7.2
现在，当您通过以下命令重新启动apache2服务时，将在系统上启用PHP 7.2。
sudo service apache2 restart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(2)通过CLI&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;使用以下命令将系统更新为现在将PHP 7.2作为默认PHP版本。
sudo update-alternatives --set php /usr/bin/php7.2
或者，您可以使用以下命令来实现相同的目的：
sudo update-alternatives --config php
该命令列出了系统上安装的所有可用PHP版本。输入要在系统上启用的版本的选择号，
然后按Enter。例如，如果输入2，则将在系统上启用PHP 5.6。
&lt;/code&gt;&lt;/pre&gt;
">linux学习之路</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/stm32mp1/"" data-c="
          &lt;p&gt;X&lt;/p&gt;
">STM32MP1</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://easyzoom.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;    分享学习&lt;/p&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;p&gt;    easyzoom&lt;/p&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;p&gt;    羽毛球、视频剪辑等等&lt;/p&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
&lt;p&gt;    1054516930@qq.com(国内)&lt;br&gt;
    easyzoom.wang@gmail.com(国外)&lt;/p&gt;
">关于</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>



<script src="/media/js/mouse/peace.js"></script>


  <script src="/media/js/cool.js"></script>



  <div class="snow-container"></div>
  <script color="0,205,205" pointer-events="auto" zIndex="-1" opacity='0.7' count="99" src="/media/js/bg/canvas-nest.js"></script>

</html>